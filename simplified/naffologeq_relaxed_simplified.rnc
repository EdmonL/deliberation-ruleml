default namespace = "http://ruleml.org/spec"
namespace xsi = "http://www.w3.org/2001/XMLSchema-instance"
namespace xs = "http://www.w3.org/2001/XMLSchema"

start =
  RuleML
  | Assert
  | Retract
  | Query
  | Atom
  | Rel
  | And
  | Or
  | And_2
  | Or_2
  | Implies
  | Forall
  | Exists
  | Expr
  | Fun
  | Data
  | Rulebase
  | Entails
  | Neg
  | Naf
  | Equivalent
  | Equal
  | Skolem
  | Reify
  | Ind
  | Var
  | Plex
  | formula
  | formula_2
  | op
  | formula_3
  | formula_4
  | then
  | if
  | declare
  | formula_5
  | formula_6
  | op_2
  | formula_7
  | then_2
  | if_2
  | degree
  | strong
  | weak
  | torso
  | oid
  | slot
  | left
  | right
  | arg
  | resl
  | repo
RuleML =
  element RuleML {
    attribute xsi:schemaLocation { text }?,
    oid?,
    (act | (Assert | Retract | Query)*)+
  }
Assert =
  element Assert {
    (attribute mapMaterial { "yes" | "no" }?
     & attribute mapDirection {
         "bidirectional" | "forward" | "backward"
       }?
     & attribute mapClosure { "universal" | "existential" }?),
    oid?,
    (formula
     | Atom
     | Equal
     | And
     | Or
     | Neg
     | Implies
     | Equivalent
     | Forall
     | Exists
     | Entails
     | Rulebase)*
  }
Retract =
  element Retract {
    (attribute mapMaterial { "yes" | "no" }?
     & attribute mapDirection {
         "bidirectional" | "forward" | "backward"
       }?
     & attribute mapClosure { "universal" | "existential" }?),
    oid?,
    (formula
     | Atom
     | Equal
     | And
     | Or
     | Neg
     | Implies
     | Equivalent
     | Forall
     | Exists
     | Entails
     | Rulebase)*
  }
Query =
  element Query {
    (attribute mapMaterial { "yes" | "no" }?
     & attribute mapDirection {
         "bidirectional" | "forward" | "backward"
       }?
     & attribute closure { "universal" | "existential" }?
     & attribute mapClosure { "universal" | "existential" }?),
    oid?,
    (formula_2
     | Atom
     | Equal
     | And_2
     | Or_2
     | Neg
     | Naf
     | Implies
     | Equivalent
     | Forall
     | Exists
     | Entails
     | Rulebase)*
  }
Atom =
  element Atom {
    attribute closure { "universal" | "existential" }?,
    (oid? & degree?),
    ((op | Rel)
     & (Skolem | Reify | Ind | Data | Data_2 | Var | Expr | Plex | arg)*
     & repo?
     & slot*
     & resl?)
  }
Rel =
  element Rel {
    attribute iri { xsd:anyURI }?,
    text
  }
And =
  element And {
    (attribute mapMaterial { "yes" | "no" }?
     & attribute mapDirection {
         "bidirectional" | "forward" | "backward"
       }?
     & attribute mapClosure { "universal" | "existential" }?),
    oid?,
    (formula_3
     | Atom
     | Equal
     | And
     | Or
     | Neg
     | Naf
     | Implies
     | Equivalent
     | Forall
     | Exists)*
  }
Or =
  element Or {
    (attribute mapMaterial { "yes" | "no" }?
     & attribute mapDirection {
         "bidirectional" | "forward" | "backward"
       }?
     & attribute mapClosure { "universal" | "existential" }?),
    oid?,
    (formula_4
     | Atom
     | Equal
     | And
     | Or
     | Neg
     | Naf
     | Implies
     | Equivalent
     | Forall
     | Exists)*
  }
And_2 =
  element And {
    (attribute mapMaterial { "yes" | "no" }?
     & attribute mapDirection {
         "bidirectional" | "forward" | "backward"
       }?
     & attribute closure { "universal" | "existential" }?
     & attribute mapClosure { "universal" | "existential" }?),
    oid?,
    (formula_3
     | Atom
     | Equal
     | And
     | Or
     | Neg
     | Naf
     | Implies
     | Equivalent
     | Forall
     | Exists)*
  }
Or_2 =
  element Or {
    (attribute mapMaterial { "yes" | "no" }?
     & attribute mapDirection {
         "bidirectional" | "forward" | "backward"
       }?
     & attribute closure { "universal" | "existential" }?
     & attribute mapClosure { "universal" | "existential" }?),
    oid?,
    (formula_4
     | Atom
     | Equal
     | And
     | Or
     | Neg
     | Naf
     | Implies
     | Equivalent
     | Forall
     | Exists)*
  }
Implies =
  element Implies {
    (attribute direction { "bidirectional" | "forward" | "backward" }?
     & attribute material { "yes" | "no" }?
     & attribute mapMaterial { "yes" | "no" }?
     & attribute mapDirection {
         "bidirectional" | "forward" | "backward"
       }?
     & attribute closure { "universal" | "existential" }?
     & attribute mapClosure { "universal" | "existential" }?),
    oid?,
    ((if & then)
     | ((Atom
         | Equal
         | And
         | Or
         | Neg
         | Implies
         | Equivalent
         | Forall
         | Exists),
        if)
     | (then,
        (Atom
         | Equal
         | And
         | Or
         | Neg
         | Naf
         | Implies
         | Equivalent
         | Forall
         | Exists))
     | ((Atom
         | Equal
         | And
         | Or
         | Neg
         | Naf
         | Implies
         | Equivalent
         | Forall
         | Exists),
        (Atom
         | Equal
         | And
         | Or
         | Neg
         | Implies
         | Equivalent
         | Forall
         | Exists))
     | ((Atom
         | Equal
         | And
         | Or
         | Neg
         | Naf
         | Implies
         | Equivalent
         | Forall
         | Exists),
        then)
     | (if,
        (Atom
         | Equal
         | And
         | Or
         | Neg
         | Implies
         | Equivalent
         | Forall
         | Exists)))
  }
Forall =
  element Forall {
    (attribute mapMaterial { "yes" | "no" }?
     & attribute mapDirection {
         "bidirectional" | "forward" | "backward"
       }?
     & attribute mapClosure { "universal" | "existential" }?),
    oid?,
    (declare | Var)+,
    (formula_5
     | Atom
     | Equal
     | And
     | Or
     | Neg
     | Implies
     | Equivalent
     | Forall
     | Exists)
  }
Exists =
  element Exists {
    (attribute mapMaterial { "yes" | "no" }?
     & attribute mapDirection {
         "bidirectional" | "forward" | "backward"
       }?
     & attribute mapClosure { "universal" | "existential" }?),
    oid?,
    (declare | Var)+,
    (formula_6
     | Atom
     | Equal
     | And
     | Or
     | Neg
     | Implies
     | Equivalent
     | Forall
     | Exists)
  }
Expr =
  element Expr {
    (attribute per { "copy" | "value" | "open" }?
     & attribute type { xsd:string }?),
    oid?,
    ((op_2 | Fun)
     & (Skolem | Reify | Ind | Data | Data_2 | Var | Expr | Plex | arg)*
     & repo?
     & slot*
     & resl?)
  }
Fun =
  element Fun {
    (attribute per { "copy" | "value" | "open" }?
     & attribute val { "1" | "0.." }?
     & attribute iri { xsd:anyURI }?),
    text
  }
Data =
  element Data {
    (attribute xsi:type { xsd:QName "xs:duration" },
     xsd:duration)
    | (attribute xsi:type { xsd:QName "xs:dateTime" },
       xsd:dateTime)
    | (attribute xsi:type { xsd:QName "xs:time" },
       xsd:time)
    | (attribute xsi:type { xsd:QName "xs:date" },
       xsd:date)
    | (attribute xsi:type { xsd:QName "xs:gYearMonth" },
       xsd:gYearMonth)
    | (attribute xsi:type { xsd:QName "xs:gYear" },
       xsd:gYear)
    | (attribute xsi:type { xsd:QName "xs:gMonthDay" },
       xsd:gMonthDay)
    | (attribute xsi:type { xsd:QName "xs:gDay" },
       xsd:gDay)
    | (attribute xsi:type { xsd:QName "xs:gMonth" },
       xsd:gMonth)
    | (attribute xsi:type { xsd:QName "xs:boolean" },
       xsd:boolean)
    | (attribute xsi:type { xsd:QName "xs:base64Binary" },
       xsd:base64Binary)
    | (attribute xsi:type { xsd:QName "xs:hexBinary" },
       xsd:hexBinary)
    | (attribute xsi:type { xsd:QName "xs:float" },
       xsd:float)
    | (attribute xsi:type { xsd:QName "xs:decimal" },
       xsd:decimal)
    | (attribute xsi:type { xsd:QName "xs:double" },
       xsd:double)
    | (attribute xsi:type { xsd:QName "xs:anyURI" },
       xsd:anyURI)
    | (attribute xsi:type { xsd:QName "xs:QName" },
       xsd:QName)
    | (attribute xsi:type { xsd:QName "xs:NOTATION" },
       xsd:NOTATION)
    | (attribute xsi:type { xsd:QName "xs:string" },
       xsd:string)
    | (attribute xsi:type { xsd:QName "xs:normalizedString" },
       xsd:normalizedString)
    | (attribute xsi:type { xsd:QName "xs:token" },
       xsd:token)
    | (attribute xsi:type { xsd:QName "xs:language" },
       xsd:language)
    | (attribute xsi:type { xsd:QName "xs:Name" },
       xsd:Name)
    | (attribute xsi:type { xsd:QName "xs:NCName" },
       xsd:NCName)
    | (attribute xsi:type { xsd:QName "xs:NMTOKEN" },
       xsd:NMTOKEN)
    | (attribute xsi:type { xsd:QName "xs:NMTOKENS" },
       xsd:NMTOKENS)
    | (attribute xsi:type { xsd:QName "xs:ENTITY" },
       xsd:ENTITY)
    | (attribute xsi:type { xsd:QName "xs:ENTITIES" },
       xsd:ENTITIES)
    | (attribute xsi:type { xsd:QName "xs:integer" },
       xsd:integer)
    | (attribute xsi:type { xsd:QName "xs:nonPositiveInteger" },
       xsd:nonPositiveInteger)
    | (attribute xsi:type { xsd:QName "xs:negativeInteger" },
       xsd:negativeInteger)
    | (attribute xsi:type { xsd:QName "xs:long" },
       xsd:long)
    | (attribute xsi:type { xsd:QName "xs:int" },
       xsd:int)
    | (attribute xsi:type { xsd:QName "xs:short" },
       xsd:short)
    | (attribute xsi:type { xsd:QName "xs:byte" },
       xsd:byte)
    | (attribute xsi:type { xsd:QName "xs:nonNegativeInteger" },
       xsd:nonNegativeInteger)
    | (attribute xsi:type { xsd:QName "xs:unsignedLong" },
       xsd:unsignedLong)
    | (attribute xsi:type { xsd:QName "xs:unsignedInt" },
       xsd:unsignedInt)
    | (attribute xsi:type { xsd:QName "xs:unsignedByte" },
       xsd:unsignedByte)
    | (attribute xsi:type { xsd:QName "xs:positiveInteger" },
       xsd:positiveInteger)
    | xsd:duration
    | xsd:dateTime
    | xsd:time
    | xsd:date
    | xsd:gYearMonth
    | xsd:gYear
    | xsd:gMonthDay
    | xsd:gDay
    | xsd:gMonth
    | xsd:boolean
    | xsd:base64Binary
    | xsd:hexBinary
    | xsd:float
    | xsd:decimal
    | xsd:double
    | xsd:anyURI
    | xsd:QName
    | xsd:NOTATION
    | xsd:string
  }
Rulebase =
  element Rulebase {
    (attribute mapMaterial { "yes" | "no" }?
     & attribute mapDirection {
         "bidirectional" | "forward" | "backward"
       }?
     & attribute mapClosure { "universal" | "existential" }?),
    oid?,
    (Atom
     | Equal
     | And
     | Or
     | Neg
     | Implies
     | Equivalent
     | Forall
     | Exists
     | formula_7)*
  }
Entails =
  element Entails {
    oid?,
    ((if_2 & then_2)
     | (Rulebase, if_2)
     | (then_2, Rulebase)
     | (Rulebase, Rulebase)
     | (Rulebase, then_2)
     | (if_2, Rulebase))
  }
Neg =
  element Neg {
    (attribute mapMaterial { "yes" | "no" }?
     & attribute mapDirection {
         "bidirectional" | "forward" | "backward"
       }?
     & attribute mapClosure { "universal" | "existential" }?),
    oid?,
    (Atom
     | Equal
     | And
     | Or
     | Neg
     | Implies
     | Equivalent
     | Forall
     | Exists
     | strong)
  }
Naf =
  element Naf {
    (attribute mapMaterial { "yes" | "no" }?
     & attribute mapDirection {
         "bidirectional" | "forward" | "backward"
       }?
     & attribute mapClosure { "universal" | "existential" }?),
    oid?,
    (Atom
     | Equal
     | And
     | Or
     | Neg
     | Implies
     | Equivalent
     | Forall
     | Exists
     | weak)
  }
Equivalent =
  element Equivalent {
    (attribute mapMaterial { "yes" | "no" }?
     & attribute mapDirection {
         "bidirectional" | "forward" | "backward"
       }?
     & attribute closure { "universal" | "existential" }?
     & attribute mapClosure { "universal" | "existential" }?),
    oid?,
    (Atom
     | Equal
     | And
     | Or
     | Neg
     | Implies
     | Equivalent
     | Forall
     | Exists
     | torso),
    (Atom
     | Equal
     | And
     | Or
     | Neg
     | Implies
     | Equivalent
     | Forall
     | Exists
     | torso)
  }
Equal =
  element Equal {
    attribute oriented { "no" | "yes" }?,
    (oid? & degree?),
    (Skolem | Reify | Ind | Data | Data_2 | Var | Expr | Plex | left),
    (Skolem | Reify | Ind | Data | Data_2 | Var | Expr | Plex | right)
  }
Skolem =
  element Skolem {
    attribute type { xsd:string }?,
    text
  }
Reify =
  element Reify {
    (RuleML
     | Assert
     | Retract
     | Query
     | Atom
     | Rel
     | And
     | Or
     | And_2
     | Or_2
     | Implies
     | Forall
     | Exists
     | Expr
     | Fun
     | Data
     | Rulebase
     | Entails
     | Neg
     | Naf
     | Equivalent
     | Equal
     | Skolem
     | Reify
     | Ind
     | Var
     | Plex
     | formula
     | formula_2
     | op
     | formula_3
     | formula_4
     | then
     | if
     | declare
     | formula_5
     | formula_6
     | op_2
     | formula_7
     | then_2
     | if_2
     | degree
     | strong
     | weak
     | torso
     | oid
     | slot
     | left
     | right
     | arg
     | resl
     | repo)?
  }
Ind =
  element Ind {
    (attribute iri { xsd:anyURI }?
     & attribute type { xsd:string }?),
    text
  }
Var =
  element Var {
    attribute type { xsd:string }?,
    text
  }
Plex =
  element Plex {
    oid?,
    ((Skolem | Reify | Ind | Data | Data_2 | Var | Expr | Plex | arg)*
     & repo?
     & slot*
     & resl?)
  }
formula =
  element formula {
    Atom
    | Equal
    | And
    | Or
    | Neg
    | Implies
    | Equivalent
    | Forall
    | Exists
    | Entails
    | Rulebase
  }
formula_2 =
  element formula {
    Atom
    | Equal
    | And_2
    | Or_2
    | Neg
    | Naf
    | Implies
    | Equivalent
    | Forall
    | Exists
    | Entails
    | Rulebase
  }
op = element op { Rel }
formula_3 =
  element formula {
    Atom
    | Equal
    | And
    | Or
    | Neg
    | Naf
    | Implies
    | Equivalent
    | Forall
    | Exists
  }
formula_4 =
  element formula {
    Atom
    | Equal
    | And
    | Or
    | Neg
    | Naf
    | Implies
    | Equivalent
    | Forall
    | Exists
  }
then =
  element then {
    Atom
    | Equal
    | And
    | Or
    | Neg
    | Implies
    | Equivalent
    | Forall
    | Exists
  }
if =
  element if {
    Atom
    | Equal
    | And
    | Or
    | Neg
    | Naf
    | Implies
    | Equivalent
    | Forall
    | Exists
  }
declare = element declare { Var }
formula_5 =
  element formula {
    Atom
    | Equal
    | And
    | Or
    | Neg
    | Implies
    | Equivalent
    | Forall
    | Exists
  }
formula_6 =
  element formula {
    Atom
    | Equal
    | And
    | Or
    | Neg
    | Implies
    | Equivalent
    | Forall
    | Exists
  }
op_2 = element op { Fun }
formula_7 =
  element formula {
    Atom
    | Equal
    | And
    | Or
    | Neg
    | Implies
    | Equivalent
    | Forall
    | Exists
  }
then_2 = element then { Rulebase }
if_2 = element if { Rulebase }
degree = element degree { Data_2 | Data }
strong =
  element strong {
    Atom
    | Equal
    | And
    | Or
    | Neg
    | Implies
    | Equivalent
    | Forall
    | Exists
  }
weak =
  element weak {
    Atom
    | Equal
    | And
    | Or
    | Neg
    | Implies
    | Equivalent
    | Forall
    | Exists
  }
torso =
  element torso {
    Atom
    | Equal
    | And
    | Or
    | Neg
    | Implies
    | Equivalent
    | Forall
    | Exists
  }
oid =
  element oid {
    Skolem | Reify | Ind | Data | Data_2 | Var | Expr | Plex
  }
slot =
  element slot {
    (attribute card { xsd:nonNegativeInteger }?
     & attribute weight {
         xsd:decimal { minInclusive = "0.0" maxInclusive = "1.0" }
       }?),
    (Ind | Data | Data_2 | Expr | Plex),
    (Skolem | Reify | Ind | Data | Data_2 | Var | Expr | Plex)
  }
left =
  element left {
    Skolem | Reify | Ind | Data | Data_2 | Var | Expr | Plex
  }
right =
  element right {
    Skolem | Reify | Ind | Data | Data_2 | Var | Expr | Plex
  }
arg =
  element arg {
    attribute index { xsd:positiveInteger },
    (Skolem | Reify | Ind | Data | Data_2 | Var | Expr | Plex)
  }
resl = element resl { Var | Plex_2 }
repo = element repo { Var | Plex_3 }
act =
  element act {
    attribute index { xsd:positiveInteger },
    (Assert | Retract | Query)*
  }
Data_2 =
  element Data {
    attribute xsi:schemaLocation { text }?,
    (text & _1*)
  }
Plex_2 = element Plex { oid?, (slot* & resl?) }
Plex_3 =
  element Plex {
    oid?,
    ((Skolem | Reify | Ind | Data | Data_2 | Var | Expr | Plex | arg)*
     & repo?)
  }
_1 =
  element * {
    attribute * { text }*,
    (text & _1*)
  }
