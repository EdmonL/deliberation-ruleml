# This schema includes and redefines James Clark's
# RELAX NG for RELAX NG
# (translated in to RNC by Trang, of course.)

namespace dc = "http://purl.org/dc/elements/1.1/"
default namespace rng = "http://relaxng.org/ns/structure/1.0"

dc:title [ "RuleML Design Pattern for Relax NG Schemas: Expansion Modules" ]
dc:version [ "1.0.01" ]
dc:creator [ "Tara Athan (taraathan AT gmail.com" ]
dc:subject [ "RuleML, design pattern" ]
dc:description [
  "This meta-schema enforces the design pattern for expansion modules when applied to a Relax NG schema in XML-based syntax. The merger of a base grammar with an expansion module gives a language which syntactically contains the language generated by the base grammar (monotonicity).  Any expansion module also satisfies the conditions of a base grammar; thus, expansion modules that are compatible (valid when merged) are  monotonically freely combinable."]
dc:date [ "2011-07-07" ]
dc:language [ "en" ]
dc:rights [ "TBD" ]
dc:relation [ "http://wiki.ruleml.org/index.php/Relax_NG" ]
dc:relation [ "http://relaxng.org/relaxng.rng" ]
include "relaxng.rnc" {
  pattern =
    element element {
      (attribute name { xsd:QName }
       | open-name-class),
      common-atts,
      open-patterns
    }
    | element attribute {
        common-atts,
        (attribute name { xsd:QName }
         | open-name-class),
        (other & pattern?)
      }
    | element group { common-atts, open-patterns }
    | element interleave { common-atts, open-patterns }
    | element choice { common-atts, open-patterns }
    | optional-element
    | zeroOrMore-element
    | element oneOrMore { common-atts, open-patterns }
    | element list { common-atts, open-patterns }
    | element mixed { common-atts, open-patterns }
    | element ref {
        attribute name { xsd:NCName },
        common-atts,
        other
      }
    | element parentRef {
        attribute name { xsd:NCName },
        common-atts,
        other
      }
    | empty-element
    | element text { common-atts, other }
    | element value {
        attribute type { xsd:NCName }?,
        common-atts,
        text
      }
    | element data {
        attribute type { xsd:NCName },
        common-atts,
        (other
         & (element param {
              attribute name { xsd:NCName },
              common-atts,
              text
            }*,
            element except { common-atts, open-patterns }?))
      }
    | element notAllowed { common-atts, other }
    | element externalRef {
        attribute href { xsd:anyURI },
        common-atts,
        other
      }
    | element grammar { common-atts, grammar-content }
  define-element = define-element.choice | define-element.interleave | define-element.noCombine
}
define-element.choice =
  element define { nameNCName.choice, combine-att.choice, common-atts, open-patterns }
define-element.interleave =
  element define { nameNCName.interleave, combine-att.interleave, common-atts, open-optional }
define-element.noCombine = element define { nameNCName.noCombine, common-atts, open-patterns }
nameNCName.choice =
  attribute name {
    xsd:NCName { pattern = "[a-zA-Z\.\-_]+\.(choice|main|content|value|datatype|sequence|defs)" }
  }
nameNCName.interleave =
  attribute name {
    xsd:NCName { pattern = "[a-zA-Z\.\-_]+\.(attlist|header|notallowed)" }
  }
nameNCName.noCombine =
  attribute name {
    xsd:NCName { pattern = "[a-zA-Z\.\-_]+\.(def)" }
  }
combine-att.choice = attribute combine { "choice" }
combine-att.interleave = attribute combine { "interleave" }
optional-element = element optional { common-atts, open-patterns }
zeroOrMore-element = element zeroOrMore { common-atts, open-patterns }
empty-element = element empty { common-atts, other }
open-optional = other & (zeroOrMore-element | optional-element | empty-element)
