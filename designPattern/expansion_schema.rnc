# This schema is derived from James Clark's
# RELAX NG for RELAX NG
# $Id: relaxng.rng,v 1.31 2002/05/30 06:07:43 jjc Exp $
# (translated in to RNC by Trang, of course.)

namespace local = ""
default namespace rng = "http://relaxng.org/ns/structure/1.0"
namespace dc = "http://purl.org/dc/elements/1.1/"
dc:title [ "RuleML Design Pattern for Relax NG Schemas: Expansion Modules" ]
dc:version [ "1.0.01" ]
dc:creator [ "Tara Athan (taraathan AT gmail.com" ]
dc:subject [ "RuleML, design pattern" ]
dc:description [ "This meta-schema enforces the design pattern for expansion modules when applied to a Relax NG schema in XML-based syntax. The merger of a base grammer with an expansion module gives a language which syntactically contains the language generated by the base grammar." ]
dc:date ["2011-06-17"]
dc:language [ "en" ]
dc:rights [ "TBD" ]
dc:relation [ "http://wiki.ruleml.org/index.php/Relax_NG" ]
dc:relation [ "http://relaxng.org/relaxng.rng" ]

start = pattern
pattern =
  element element {
    (attribute name { xsd:QName }
     | open-name-class),
    common-atts,
    open-patterns
  }
  | element attribute {
      common-atts,
      (attribute name { xsd:QName }
       | open-name-class),
      (other & pattern?)
    }
  | element group { common-atts, open-patterns }
  | element interleave { common-atts, open-patterns }
  | element choice { common-atts, open-patterns }
  | optional-element
  | element zeroOrMore { common-atts, open-patterns }
  | element oneOrMore { common-atts, open-patterns }
  | element list { common-atts, open-patterns }
  | element mixed { common-atts, open-patterns }
  | element ref {
      attribute name { xsd:NCName },
      common-atts,
      other
    }
  | element parentRef {
      attribute name { xsd:NCName },
      common-atts,
      other
    }
  | empty-element
  | element text { common-atts, other }
  | element value {
      attribute type { xsd:NCName }?,
      common-atts,
      text
    }
  | element data {
      attribute type { xsd:NCName },
      common-atts,
      (other
       & (element param {
            attribute name { xsd:NCName },
            common-atts,
            text
          }*,
          element except { common-atts, open-patterns }?))
    }
  | element notAllowed { common-atts, other }
  | element externalRef {
      attribute href { xsd:anyURI },
      common-atts,
      other
    }
  | element grammar { common-atts, grammar-content }
grammar-content =
  other
  & (start-element
     | define-element
     | element div { common-atts, grammar-content }
     | element include {
         attribute href { xsd:anyURI },
         common-atts,
         include-content
       })*
include-content =
  other
  & (start-element
     | define-element
     | element div { common-atts, include-content })*
start-element = element start { combine-att.choice, common-atts, open-pattern }
#define-element =
#  element define {
#    attribute name { xsd:NCName },
#    combine-att,
#    common-atts,
#    open-patterns
#  }
define-element = (define-element.choice | define-element.interleave | define-element.noCombine)
define-element.choice =  
  element define { nameNCName.choice, combine-att.choice, common-atts, open-patterns }
define-element.interleave =  
  element define { nameNCName.interleave, combine-att.interleave, common-atts , open-optional }
define-element.noCombine =  
  element define { nameNCName.noCombine, common-atts, open-patterns }

nameNCName.choice = attribute name {xsd:NCName {pattern = "[a-zA-Z\.\-_]+\.(choice|main|content|value|datatype|sequence|defs)"}}  
nameNCName.interleave = attribute name {xsd:NCName {pattern = "[a-zA-Z\.\-_]+\.(attlist|header|notallowed)"}}  
nameNCName.noCombine = attribute name {xsd:NCName {pattern = "[a-zA-Z\.\-_]+\.(def)"}}  

combine-att = attribute combine { "choice" | "interleave" }?
combine-att.choice = attribute combine { "choice" }
combine-att.interleave = attribute combine { "interleave" }

optional-element = element optional { common-atts, open-patterns }
empty-element = element empty { common-atts, other }
open-optional = other & (optional-element | empty-element)
open-patterns = other & pattern+
open-pattern = other & pattern
name-class =
  element name { common-atts, xsd:QName }
  | element anyName { common-atts, except-name-class }
  | element nsName { common-atts, except-name-class }
  | element choice { common-atts, open-name-classes }
except-name-class =
  other
  & element except { open-name-classes }?
open-name-classes = other & name-class+
open-name-class = other & name-class
common-atts =
  attribute ns { text }?,
  attribute datatypeLibrary { xsd:anyURI }?,
  attribute * - (rng:* | local:*) { text }*
other =
  element * - rng:* {
    (attribute * { text }
     | text
     | any)*
  }*
any =
  element * {
    (attribute * { text }
     | text
     | any)*
  }
