<?xml version="1.0" encoding="UTF-8"?>
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema" elementFormDefault="qualified" targetNamespace="http://www.ruleml.org/0.91/xsd" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:ruleml="http://www.ruleml.org/0.91/xsd">
  <xs:import namespace="http://www.w3.org/2001/XMLSchema-instance" schemaLocation="explicit_datatyping_extension_module.xsd"/>
  <!--
    This module declares the following RuleML elements and attribute:
               * <RuleML> !
               * <Assert> !
               * <Retract>
               * <Query>
               * <formula>
               * AssertRetractFormula.choice
               * QueryFormula.choice
  -->
  <xs:group name="performative.Node.defs">
    <xs:annotation>
      <xs:documentation/>
    </xs:annotation>
    <xs:choice>
      <xs:element ref="ruleml:RuleML"/>
      <xs:element ref="ruleml:Assert"/>
      <xs:element ref="ruleml:Retract"/>
      <xs:element ref="ruleml:Query"/>
    </xs:choice>
  </xs:group>
  <xs:group name="performative.edge.defs">
    <xs:choice>
      <xs:group ref="ruleml:formula_AssertRetract.edge.def"/>
      <xs:group ref="ruleml:formula_Query.edge.def"/>
    </xs:choice>
  </xs:group>
  <xs:element name="RuleML">
    <xs:annotation>
      <xs:documentation>The polyadic top_level of a RuleML document.
See http://www.ruleml.org/0.91/glossary/#gloss-RuleML</xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:sequence>
        <xs:group ref="ruleml:RuleML.header"/>
        <xs:group ref="ruleml:RuleML.main"/>
      </xs:sequence>
      <xs:attributeGroup ref="ruleml:RuleML.attlist"/>
    </xs:complexType>
  </xs:element>
  <!-- The attribute list of the RuleML root element is initialized empty, but may be over-ridden by optional modules. -->
  <xs:attributeGroup name="RuleML.attlist">
    <xs:attribute ref="xsi:schemaLocation"/>
  </xs:attributeGroup>
  <!-- The header of the RuleML root element accepts the Performative header pattern. -->
  <xs:group name="RuleML.header">
    <xs:sequence>
      <xs:group minOccurs="0" ref="ruleml:Performative.header"/>
    </xs:sequence>
  </xs:group>
  <xs:group name="RuleML.main">
    <xs:annotation>
      <xs:documentation>The RuleML root element contains zero or more performatives.</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:group minOccurs="0" maxOccurs="unbounded" ref="ruleml:Performative.choice"/>
    </xs:sequence>
  </xs:group>
  <xs:group name="Performative.choice">
    <xs:annotation>
      <xs:documentation>Performatives include assertions, retractions and queries.</xs:documentation>
    </xs:annotation>
    <xs:choice>
      <xs:group ref="ruleml:AssertRetract-node.choice"/>
      <xs:group ref="ruleml:Query-node.choice"/>
    </xs:choice>
  </xs:group>
  <xs:group name="AssertRetract-node.choice">
    <xs:annotation>
      <xs:documentation>a convenience pattern combining assertions and retractions</xs:documentation>
    </xs:annotation>
    <xs:choice>
      <xs:group ref="ruleml:Assert-node.choice"/>
      <xs:group ref="ruleml:Retract-node.choice"/>
    </xs:choice>
  </xs:group>
  <xs:group name="Assert-node.choice">
    <xs:annotation>
      <xs:documentation>an extension point for alternate spellings and internationalization of the assertion tag name.  </xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element ref="ruleml:Assert"/>
    </xs:sequence>
  </xs:group>
  <xs:element name="Assert">
    <xs:annotation>
      <xs:documentation>A KQML-like performative acting as a wrapper specifying that its content is 
asserted, making an 'implicit &lt;Rulebase&gt;' assumption.
See http://www.ruleml.org/0.91/glossary/#gloss-Assert</xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:sequence>
        <xs:group ref="ruleml:AssertRetract.header"/>
        <xs:group ref="ruleml:AssertRetract.main"/>
      </xs:sequence>
      <xs:attributeGroup ref="ruleml:AssertRetract.attlist"/>
    </xs:complexType>
  </xs:element>
  <xs:group name="Retract-node.choice">
    <xs:annotation>
      <xs:documentation>an extension point for alternate spellings and internationalization of the retraction tag name.  </xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element ref="ruleml:Retract"/>
    </xs:sequence>
  </xs:group>
  <xs:element name="Retract">
    <xs:annotation>
      <xs:documentation>A performative similar to KQML's 'untell' that acts as a wrapper specifying that its
content is to be deleted, making an 'implicit &lt;Rulebase&gt;' assumption.
See http://www.ruleml.org/0.91/glossary/#gloss-Retract</xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:sequence>
        <xs:group ref="ruleml:AssertRetract.header"/>
        <xs:group ref="ruleml:AssertRetract.main"/>
      </xs:sequence>
      <xs:attributeGroup ref="ruleml:AssertRetract.attlist"/>
    </xs:complexType>
  </xs:element>
  <xs:attributeGroup name="AssertRetract.attlist">
    <xs:annotation>
      <xs:documentation>Assertions and retractions may have an optional scope closure attribute.</xs:documentation>
    </xs:annotation>
    <xs:attributeGroup ref="ruleml:mapClosure-att.choice"/>
    <xs:attributeGroup ref="ruleml:mapDirection-att.choice"/>
    <xs:attributeGroup ref="ruleml:mapMaterial-att.choice"/>
  </xs:attributeGroup>
  <!--
    AssertRetract.attlist = mapDirection-att.option & mapMaterial-att.option & mapClosure-att.choice?
    For the declaration of the scope closure attribute pattern, see the quantification closure module (closure_extension_module)
  -->
  <xs:group name="AssertRetract.header">
    <xs:annotation>
      <xs:documentation>Assertions and retractions accept the performative header pattern.</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:group minOccurs="0" ref="ruleml:Performative.header"/>
    </xs:sequence>
  </xs:group>
  <!-- The object header is initialized to be empty, and may be over-ridden by optional modules. See the object identifier module (desc_module). -->
  <xs:group name="AssertRetract.main">
    <xs:annotation>
      <xs:documentation>Assertions and retractions contain zero or more formulas.</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:group minOccurs="0" maxOccurs="unbounded" ref="ruleml:formula_AssertRetract-edge.choice"/>
    </xs:sequence>
  </xs:group>
  <xs:group name="formula_AssertRetract-edge.choice">
    <xs:annotation>
      <xs:documentation>an extension point for stripe skipping as well as alternate spellings and internationalization of the formula tag name in assertions and retractions.  </xs:documentation>
    </xs:annotation>
    <xs:choice>
      <xs:group ref="ruleml:formula_AssertRetract.edge.def"/>
      <xs:group ref="ruleml:formula_AssertRetract.content"/>
    </xs:choice>
  </xs:group>
  <xs:group name="formula_AssertRetract.edge.def">
    <xs:sequence>
      <xs:element name="formula">
        <xs:annotation>
          <xs:documentation>The formula role of a conjunctive (&lt;And&gt;) or disjunctive (&lt;Or&gt;) expression, 
quantifier (&lt;Forall&gt; or &lt;Exists&gt;), or performative (&lt;Assert&gt;, &lt;Query&gt; or &lt;Retract&gt;).
See http://www.ruleml.org/0.91/glossary/#gloss-formula
Within Assert or Retract...</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:group ref="ruleml:formula_AssertRetract.content"/>
        </xs:complexType>
      </xs:element>
    </xs:sequence>
  </xs:group>
  <xs:group name="formula_AssertRetract.content">
    <xs:annotation>
      <xs:documentation>Forumulas within assertions and retractions contain a single formula.</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:group ref="ruleml:AssertRetractFormula.choice"/>
    </xs:sequence>
  </xs:group>
  <xs:group name="AssertRetractFormula.choice">
    <xs:annotation>
      <xs:documentation>Formulas allowed in assertions and retractions:
Simple formulas are allowed in assertions and retractions in all sub-languages.
Conjunctions and disjunctions are allowed in assertions and retractions in sub-languages that contain these components.
Implications and universal quantifications is allowed in assertions and retractions for all quantified sub-languages.
Strong and weak negation are allowed in assertions and retractions for all sub-languages that contain these components.
Existential quantification is added to assertions and retractions for full first-order sub-languages.</xs:documentation>
    </xs:annotation>
    <xs:choice>
      <xs:group ref="ruleml:SimpleFormula-node.choice"/>
      <xs:choice>
        <xs:group ref="ruleml:Entails-node.choice"/>
        <xs:group ref="ruleml:Rulebase-node.choice"/>
      </xs:choice>
    </xs:choice>
  </xs:group>
  <!--
    For the declaration of the simple formula pattern, see the atomic formula and equation modules ( atom_backbone_module and equal_module) 
    For the declaration of conjunctive and disjunctive formula patterns, see the conjunction and disjunction module (andor_module)
    For the declaration of the strong negation formula pattern, see the strong negation module ( neg_extension_module) 
    For the declaration of the weak negation formula pattern, see the weak negation module ( naf_extension_module) 
    For the declaration of the implication pattern, see the implication modules (implication_module and equivalence_module)
    For the declaration of the quantification patterns, see the quantification module (quantifier_module)
    For patterns containing "fo" see the first-order logic module (folog_base_module)
  -->
  <!-- For the declaration of the entailment and rulebase patterns, see the meta-logic module (meta_module) -->
  <xs:group name="Query-node.choice">
    <xs:annotation>
      <xs:documentation>an extension point for alternate spellings and internationalization of the query tag name.  </xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element ref="ruleml:Query"/>
    </xs:sequence>
  </xs:group>
  <xs:element name="Query">
    <xs:annotation>
      <xs:documentation>A KQML-like performative acting as a wrapper specifying that its content is
queried, making an 'implicit &lt;Rulebase&gt;' assumption.
See http://www.ruleml.org/0.91/glossary/#gloss-Query</xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:sequence>
        <xs:group ref="ruleml:Query.header"/>
        <xs:group ref="ruleml:Query.main"/>
      </xs:sequence>
      <xs:attributeGroup ref="ruleml:Query.attlist"/>
    </xs:complexType>
  </xs:element>
  <xs:attributeGroup name="Query.attlist">
    <xs:annotation>
      <xs:documentation>Queries may have an optional map closure attribute.</xs:documentation>
    </xs:annotation>
    <xs:attributeGroup ref="ruleml:closure-att.choice"/>
  </xs:attributeGroup>
  <!-- For the declaration of the closure attribute pattern, see the quantification closure module (closure_extension_module) -->
  <xs:group name="Query.header">
    <xs:annotation>
      <xs:documentation>Queries accept the header patter common to formulas.</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:group minOccurs="0" ref="ruleml:Performative.header"/>
    </xs:sequence>
  </xs:group>
  <!--
    The object header may be positionally-dependent, 
    see the position-(in)dependence serialization modules (orderstrict_module, orderlax_module).
  -->
  <xs:group name="Query.main">
    <xs:annotation>
      <xs:documentation>The content model of queries consists of zero or more formulas.</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:group minOccurs="0" maxOccurs="unbounded" ref="ruleml:formula_Query-edge.choice"/>
    </xs:sequence>
  </xs:group>
  <xs:group name="formula_Query-edge.choice">
    <xs:annotation>
      <xs:documentation>an extension point for stripe skipping as well as alternate spellings and internationalization of the formula tag name in queries.  </xs:documentation>
    </xs:annotation>
    <xs:choice>
      <xs:group ref="ruleml:formula_Query.edge.def"/>
      <xs:group ref="ruleml:formula_Query.content"/>
    </xs:choice>
  </xs:group>
  <xs:group name="formula_Query.edge.def">
    <xs:sequence>
      <xs:element name="formula">
        <xs:annotation>
          <xs:documentation>The formula role of a conjunctive (&lt;And&gt;) or disjunctive (&lt;Or&gt;) expression, 
quantifier (&lt;Forall&gt; or &lt;Exists&gt;), or performative (&lt;Assert&gt;, &lt;Query&gt; or &lt;Retract&gt;).
See http://www.ruleml.org/0.91/glossary/#gloss-formula
Within Query ...</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:group ref="ruleml:formula_Query.content"/>
        </xs:complexType>
      </xs:element>
    </xs:sequence>
  </xs:group>
  <xs:group name="formula_Query.content">
    <xs:annotation>
      <xs:documentation>The content model of a forumula within queries is a single formula.</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:group ref="ruleml:QueryFormula.choice"/>
    </xs:sequence>
  </xs:group>
  <xs:group name="QueryFormula.choice">
    <xs:annotation>
      <xs:documentation>Formulas allowed in queries:
Simple formulas are allowed in queries in all sub-languages.
Conjunctions and disjunctions are allowed in queries in sub-languages that contain these components.
Existential quantifications is allowed in queries for all quantified sub-languages.
Strong and weak negation are allowed in queries for all sub-languages that contain these components.
Implications and universal quantification are added to queries for full first-order sub-languages.</xs:documentation>
    </xs:annotation>
    <xs:choice>
      <xs:choice>
        <xs:group ref="ruleml:SimpleFormula-node.choice"/>
        <xs:group ref="ruleml:And-Query-node.choice"/>
        <xs:group ref="ruleml:Or-Query-node.choice"/>
      </xs:choice>
      <xs:choice>
        <xs:group ref="ruleml:Entails-node.choice"/>
        <xs:group ref="ruleml:Rulebase-node.choice"/>
      </xs:choice>
    </xs:choice>
  </xs:group>
  <!--
    For the declaration of the simple formula pattern, see the atomic formula and equation modules ( atom_backbone_module and equal_module) 
    For the declaration of conjunctive and disjunctive formula patterns, see the conjunction and disjunction module (andor_module)
    For the declaration of the strong negation formula pattern, see the strong negation module ( neg_extension_module) 
    For the declaration of the weak negation formula pattern, see the weak negation module ( naf_extension_module) 
    For the declaration of the implication pattern, see the implication modules (implication_module and equivalence_module)
    For the declaration of the quantification patterns, see the quantification module (quantifier_module)
  -->
  <!-- For the declaration of the entailment and rulebase formula pattern, see the meta-logic and rulebase modules ( meta_module and rulebase_module) -->
  <xs:group name="Node.choice">
    <xs:choice>
      <xs:group ref="ruleml:performative.Node.defs"/>
      <xs:group ref="ruleml:atom.Node.defs"/>
      <xs:group ref="ruleml:andor.Node.defs"/>
      <xs:group ref="ruleml:Data_simple.Node.def"/>
      <xs:element ref="ruleml:Rulebase"/>
      <xs:element ref="ruleml:Entails"/>
      <xs:element ref="ruleml:Skolem"/>
      <xs:element ref="ruleml:Reify"/>
      <xs:element ref="ruleml:Ind"/>
      <xs:element ref="ruleml:Var"/>
    </xs:choice>
  </xs:group>
  <xs:group name="edge.choice">
    <xs:choice>
      <xs:group ref="ruleml:performative.edge.defs"/>
      <xs:group ref="ruleml:atom.edge.defs"/>
      <xs:group ref="ruleml:andor.edge.defs"/>
      <xs:group ref="ruleml:formula_Rulebase.edge.def"/>
      <xs:choice>
        <xs:element ref="ruleml:head"/>
        <xs:element ref="ruleml:body"/>
      </xs:choice>
      <xs:element ref="ruleml:degree"/>
      <xs:element ref="ruleml:oid"/>
      <xs:element ref="ruleml:slot"/>
      <xs:element ref="ruleml:arg"/>
    </xs:choice>
  </xs:group>
</xs:schema>
<!--
  
  Optional initialization module allows this module to be independently validated
  include "init_extension_module.rnc"
-->
