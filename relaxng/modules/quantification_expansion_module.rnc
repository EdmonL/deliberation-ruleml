namespace dc = "http://purl.org/dc/elements/1.1/"
namespace dcterms = "http://purl.org/dc/terms/"
default namespace this = inherit


dc:title [ "RuleML Quantification" ]
dc:version [ "1.02" ]
dc:creator [ "Tara Athan (taraathan AT gmail.com" ]
dc:subject [ "RuleML, quantify, quantification, universal, existential" ]
dc:description [ "The expansion module for quantifications." ]
dc:language [ "en" ]
dcterms:rights [ "TBD" ] 
dc:relation [ "http://deliberation.ruleml.org/1.02" ]
start |= Forall.Node.def | Exists.Node.def | declare.edge.def | formula_Forall.edge.def | formula_Exists.edge.def
Node.choice |= Forall.Node.def | Exists.Node.def
edge.choice |= declare.edge.def | formula_Forall.edge.def | formula_Exists.edge.def
# This module declares the following RuleML elements and attributes:
#            * <Forall> !
#            * <Exists> !
#            * <declare>
#            * <formula>
# This module also declares the following RuleML choice patterns:
#            * ForallFormula.choice
#            * ExistsFormula.choice

## an extension point to allow alternate names and internationalization of universal quantifiers
Forall-node.choice |= Forall.Node.def
Forall.Node.def =
    
    ## Explicit universal quantifier. It consists of a sequence of one or more 
    ## variables (<Var>), each optionally surrounded by a <declare> role, and a
    ## logical formula (optionally surrounded by a <formula> role).
    ## See http://ruleml.org/1.02/glossary/#gloss-Forall
    element Forall { Forall.type.def }
Forall.type.def = (Forall-datt.choice & reForall.attlist), Forall.header, Forall.main
## The attribute list of the universal quantification formula 
##will accept a scoped closure attribute at full first-order logic.
reForall.attlist &= closure-att-fo.choice?
reForall.attlist &= mapClosure-att-fo.choice?

## Universally qualified formulas aaccept the header patter common to truth-valued connectives.
Forall.header &= TruthValuedConnective.header?
# For the declaration of the TruthValuedConnective header, see the modules ordered_groups_expansion_module and unordered_groups_expansion_module).

## Universally qualified formulas contain a sequence of bound variables and one formula.
Forall.main |= boundVariables.choice, formula_Forall-edge.choice

## an extension point to allow alternate names and internationalization for existential quantifiers
Exists-node.choice |= Exists.Node.def
Exists.Node.def =
    
    ## Explicit existential quantifier. It consists of one or more variables (<Var>),
    ## each optionally surrounded by a <declare> role, followed by a logical formula 
    ## (optionally surrounded by a <formula> role).
    ## See http://ruleml.org/1.02/glossary/#gloss-Exists
    element Exists { Exists.type.def }
Exists.type.def = (Exists-datt.choice & reExists.attlist), Exists.header, Exists.main
## The attribute list of the existential quantification formula 
## will accept a scoped closure attribute at full first-order logic.
reExists.attlist &= closure-att-fo.choice?
reExists.attlist &= mapClosure-att-fo.choice?

## Existential quantifications accept the header patter common to truth-valued connectives.
Exists.header &= TruthValuedConnective.header?
# For the declaration of the TruthValuedConnective header, see the modules ordered_groups_expansion_module and unordered_groups_expansion_module).

## Existentially qualified formulas contain a sequence of bound variables and one formula.
Exists.main |= boundVariables.choice, formula_Exists-edge.choice

## declaration of one or more bound quantifiable terms.
boundVariables.choice |= declare-edge.choice+

## an extension point for stripe skipping as well as specializations of the declare tag name in quantified formulas.  
declare-edge.choice |= declare.edge.def
declare.edge.def =
    
    ## A role used for variables (<Var>) declared within a quantifier (<Forall> or <Exists>).
    ## See http://ruleml.org/1.02/glossary/#gloss-declare
    element declare { declare.type.def }
declare.type.def = declare.attlist? & declare.content
## a declaration element contains a single quantifiable term
declare.content |= SimpleQuantifiableTerm.choice

## an extension point for stripe skipping as well as specializations of the formula tag name in universal quantifications. 
formula_Forall-edge.choice |= formula_Forall.edge.def
formula_Forall.edge.def =
    
    ## The formula role of a conjunctive (<And>) or disjunctive (<Or>) expression, 
    ## quantifier (<Forall> or <Exists>), or performative (<Assert>, <Query> or <Retract>).
    ## See http://ruleml.org/1.02/glossary/#gloss-formula
    ## within Forall...
    element formula { formula_Forall.type.def }
formula_Forall.type.def = formula_Forall.attlist? & formula_Forall.content
## The formula role of universal quantifications contains a single formula. 
formula_Forall.content |= ForallFormula.choice

## formulas allowed to be universally quantified.
ForallFormula.choice |=
    SimpleFormula-node.choice
    | And-fo-node.choice
    | Or-fo-node.choice
    | Negation-node.choice
    | NegationAsFailure-node.notallowed
    | Implication-node.choice
    | Forall-node.choice
    | Exists-fo-node.choice
# For the declaration of the simple formula pattern, see the atomic formula module ( atom_expansion_module) 
# For the declaration of conjunctive and disjunctive formula patterns, see the conjunction and disjunction module (andor_expansion_module)
# For the declaration of the strong negation formula pattern, see the strong negation module ( neg_expansion_module) 
# For the declaration of the weak negation formula pattern, see the weak negation module ( naf_expansion_module) 
# For the declaration of the implication pattern, see the implication modules (implication_expansion_module and equivalence_expansion_module)

## an extension point for stripe skipping as well as specializations of the formula tag name in existential quantifications. 
formula_Exists-edge.choice |= formula_Exists.edge.def
formula_Exists.edge.def =
    
    ## The formula role of a conjunctive (<And>) or disjunctive (<Or>) expression, 
    ## quantifier (<Forall> or <Exists>), or performative (<Assert>, <Query> or <Retract>).
    ## See http://ruleml.org/1.02/glossary/#gloss-formula
    ## Within Exists...
    element formula { formula_Exists.type.def }
formula_Exists.type.def = formula_Exists.attlist? & formula_Exists.content

## The formula role of existential quantifications contains a single formula.
formula_Exists.content |= ExistsFormula.choice

## formulas allowed to be existentially quantified.
ExistsFormula.choice |=
    SimpleFormula-node.choice
    | And-node.choice
    | Or-node.choice
    | Negation-node.choice
    | NegationAsFailure-node.notallowed
    | Implication-fo-node.choice
    | Forall-fo-node.choice
    | Exists-node.choice
# For the declaration of the simple formula pattern, see the atomic formula module ( atom_expansion_module) 
# For the declaration of conjunctive and disjunctive formula patterns, see the conjunction and disjunction module (andor_expansion_module)
# For the declaration of the strong negation formula pattern, see the strong negation module ( neg_expansion_module) 
# For the declaration of the weak negation formula pattern, see the weak negation module ( naf_expansion_module) 
# For the declaration of the implication pattern, see the implication modules (implication_expansion_module and equivalence_expansion_module)
reForall.attlist &= commonNode.attlist?
reExists.attlist &= commonNode.attlist?
declare.attlist &= commonInit.attlist?
formula_Forall.attlist &= commonInit.attlist?
formula_Exists.attlist &= commonInit.attlist?
