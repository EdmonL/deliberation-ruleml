namespace dc = "http://purl.org/dc/elements/1.1/"

dc:title [ "RuleML Expressions" ]
dc:version [ "0.91.01" ]
dc:creator [ "Tara Athan (taraathan AT gmail.com" ]
dc:subject [ "RuleML, expressions" ]
dc:description [ "The auxiliary module for expressions." ]
dc:date [ "2011-04-18" ]
dc:language [ "en" ]
dc:rights [ "TBD" ]
dc:relation [ "http://wiki.ruleml.org/index.php/Relax_NG" ]
start |= Expr.Node.defs | Fun.Node.defs | op_Expr.edge.defs
# This module declares the following RuleML elements and attributes:
#            * <Expr>
#            * <op>
#            * <Fun>
# FIXME: orthogonalize wrt treatment of default attributes

## an extension point for alternate spellings and internationalization of the expression tag name. 
Expression-node.choice |= Expr.Node.defs
Expr.Node.defs |= ExprInUn.Node.def | ExprInYes.Node.def
ExprInUn.Node.def =
    
    ## A logical function of the form "f(...)" where f is a function name. 
    ## The function name (<Fun>) is followed by a sequence of zero or more arguments (<arg>). 
    ## Optional user-defined slots (<slot>) are also permitted before and/or after the arguments, just like an atom (<Atom>).	
    ## Rest variables (<repo> and <resl>) are also permitted.
    ## See http://www.ruleml.org/1.0/glossary/#gloss-Expr
    ## Uninterpreted expressions
    element Expr {
        ((attribute in { "no" }?
          | attribute in { "semi" })
         & reExpr.attlist),
        Expr.header,
        ExprInUn.main
    }

##
ExprInYes.Node.def =
    
    ## Interpreted expressions
    element Expr {
        (attribute in { "yes" }
         & reExpr.attlist),
        Expr.header,
        ExprInYes.main
    }

## Expressions optionally accept the attribute pattern of objects with user-defined types.
reExpr.attlist &= Type.attlist?

## Expressions accept the header pattern of general objects.
reExpr.header &= Object.header?

## Pre-fix operator notation for expressions is optional in the relaxed-form serialization.
## This pattern cannot be translated accurately into XSD.
ExprInUn.main |= operatorForExpressionsInUn-edge.choice & reExprUn.main
ExprInYes.main |= operatorForExpressionsInYes-edge.choice & reExpr.main
reExprInUn.main |= argumentsForExpressionsInUn.sequence
argumentsForExpressionsInUn.sequence |=
    positionalArgumentsForExpressionsInUn.sequence & slotsForExpressionsInUn.sequence
positionalArgumentsForExpressionsInUn.sequence |=
    termsForExpressionsInUn.sequence & restOfPositionalArgumentsInUn-edge.choice?
termsForExpressionsInUn.sequence |= termsInUnPlus.sequence?
slotsForExpressionsInUn.sequence |= slotTermsForExpressionsInUn.sequence & restOfSlotsInUn-edge.choice?
#
reExpr.main |= argumentsForExpressions.sequence
argumentsForExpressions.sequence |=
    positionalArgumentsForExpressions.sequence & slotsForExpressions.sequence
positionalArgumentsForExpressions.sequence |=
    termsForExpressions.sequence & restOfPositionalArguments-edge.choice?
termsForExpressions.sequence |= termsPlus.sequence?
slotsForExpressions.sequence |= slotTermsForExpressions.sequence & restOfSlots-edge.choice?

## an extension point for stripe skipping as well as alternate spellings and internationalization of the operator tag name in expressions. 
operatorForExpressions-edge.choice |= op_Expr.edge.defs
op_Expr.edge.defs |= op_ExprInUn.edge.def | op_ExprInYes.edge.def

##
operatorForExpressionsInUn-edge.choice |= op_ExprInUn.edge.def
op_ExprInUn.edge.def =
    
    ## (context sensitive: see Also atom_backbone_module and holog_module)
    ## An operator expression including a function name (<Fun>) of a (<Expr>).
    ##        See http://www.ruleml.org/1.0/glossary/#gloss-op
    ## uninterpreted operators
    element op { op_ExprInUn.content }

## The operator role of an expression is filled by a functor.
op_ExprInUn.content |= FunctionInUn-node.choice

##
operatorForExpressionsInYes-edge.choice |= op_ExprInYes.edge.def
op_ExprInYes.edge.def =
    
    ## (context sensitive: see Also atom_backbone_module and holog_module)
    ## An operator expression including a function name (<Fun>) of a (<Expr>).
    ##        See http://www.ruleml.org/1.0/glossary/#gloss-op
    ## interpreted operators
    element op { op_ExprInYes.content }

## The operator role of an expression is filled by a functor.
op_ExprInYes.content |= FunctionInYes-node.choice

##
Function-node.choice |= Fun.Node.defs
Fun.Node.defs |= FunInUn.Node.def | FunInYes.Node.def

## an extension point for alternate spellings and internationalization of the function operator tag name.
## uninterpreted functions
## the relaxed-form is given. Alternates are:
## cl-form: no "in" attribute
## normal-form: required "in" attribute
FunctionInUn-node.choice |= FunInUn.Node.def
FunInUn.Node.def =
    
    ## A user-defined function name of an <Expr>. It is optionally surrounded by an operator (<op>).
    ##        See http://www.ruleml.org/1.0/glossary/#gloss-Fun
    element Fun {
        ((attribute in { "no" }?
          | attribute in { "semi" })
         & reFun.attlist),
        Fun.content
    }

## interpreted functions
FunctionInYes-node.choice |= FunInYes.Node.def
FunInYes.Node.def =
    
    ## A user-defined function name of an <Expr>. It is optionally surrounded by an operator (<op>).
    ##        See http://www.ruleml.org/1.0/glossary/#gloss-Fun
    element Fun {
        (attribute in { "yes" }
         & reFun.attlist),
        Fun.content
    }

## functors accept the resource attribute list
reFun.attlist &= Resource.attlist?

## A functor contains text.
Fun.content |= text
#
Node.choice |= Expr.Node.defs | Fun.Node.defs
edge.choice |= op_Expr.edge.defs
#
# include "init_extension_module.rnc"
