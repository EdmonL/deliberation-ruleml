default namespace this = inherit
namespace dc = "http://purl.org/dc/elements/1.1/"

dc:title [ "RuleML Conjunctions and Disjunctions" ]
dc:version [ "1.0.01" ]
dc:creator [ "Tara Athan (taraathan AT gmail.com" ]
dc:subject [ "RuleML, conjunction, disjunction" ]
dc:description [ "The auxiliary module for conjunctions and disjunctions." ]
dc:date ["2011-05-24"]
dc:language [ "en" ]
dc:rights [ "TBD" ]
dc:relation [ "http://wiki.ruleml.org/index.php/Relax_NG" ]
start |= andor.Node.defs | andor.edge.defs
# This module declares the following RuleML elements and attributes:
#            * <And>
#            * <Or>
#            * <formula>
# This module also declares the following RuleML choice pattern:
#            * AndFormula.choice
#            * OrFormula.choice
andor.Node.defs |= And.Node.def | Or.Node.def | And-Query.Node.def | Or-Query.Node.def
andor.edge.defs |= formula_And.edge.def | formula_Or.edge.def

## an extension point for alternate spellings and internationalization of the conjunction tag name.
And-node.choice |= And.Node.def
And.Node.def =
    
    ## A conjunctive expression, where <And>Atom</And> is equivalent to Atom.
    ## See http://www.ruleml.org/1.0/glossary/#gloss-And
    ## Within anything other than Query...
    element And { And.attlist, And.header, And.main }
# The attribute list of the conjunction element is initialized empty , but may be over-ridden by extension modules.
And.attlist &= empty

## an extension point for alternate spellings and internationalization of the conjunction tag name in queries.  
And-Query-node.choice |= And-Query.Node.def
And-Query.Node.def =
    
    ## A conjunctive expression, where <And>Atom</And> is equivalent to Atom.
    ## See http://www.ruleml.org/1.0/glossary/#gloss-And
    ## Within Query...
    element And { And-Query.attlist, And.header, And.main }

## Within query, conjunctions may have an optional existential closure attribute.
And-Query.attlist &= closure-att.choice?
# For the declaration of the closure attribute pattern, see the quantification closure module (closure_extension_module)

## The header section of the implication content model follows a common pattern for formulas.
And.header &= CompoundFormula.header?

## Compound formulas are crisp (not fuzzifiable) and therefore contain only the pattern for general formulas
CompoundFormula.header &= FuzzyFormula-header.choice?
# The formula header may be serialization-dependent, 
# see the serialization modules (orderlax_module, orderstrict_module, ordermix_module).

## The main section of the conjunction content model contains zero or more formulas.
And.main |= formula_And-edge.choice*

## an extension point for stripe skipping as well as alternate spellings and internationalization of the formula tag name in conjunctions.  
formula_And-edge.choice |= formula_And.edge.def
formula_And.edge.def =
    
    ## The formula role of a conjunctive (<And>) or disjunctive (<Or>) expression, 
    ## quantifier (<Forall> or <Exists>), or performative (<Assert>, <Query> or <Retract>).
    ## See http://www.ruleml.org/1.0/glossary/#gloss-formula
    ## Within And ...
    element formula { formula_And.content }

## Formulas within disjunctions consist of a single formula
formula_And.content |= AndFormula.choice

## formulas allowed to participate in conjunctions. 
AndFormula.choice |=
    SimpleFormula-node.choice
    | And-node.choice
    | Or-node.choice
    | Negation-node.choice
    | NegationAsFailure-node.choice
    | Implication-fo-node.choice
    | Forall-fo-node.choice
    | Exists-fo-node.choice
# For the declaration of the simple formula pattern, see the atomic formula and equation modules ( atom_backbone_module and equal_module) 
# For the declaration of the strong negation formula pattern, see the strong negation module ( neg_extension_module) 
# For the declaration of the weak negation formula pattern, see the weak negation module ( naf_extension_module) 
# For the declaration of the implication pattern, see the implication modules (implication_module and equivalence_module)
# For the declaration of the quantification patterns, see the quantification module (quantifier_module)

## a convenience pattern that unifies atomic formulas and equations
## because equations are allowed wherever atomic formulas are allowed.
# SimpleFormula-node.choice |= Atom-node.choice | Equal-node.choice
# For the declaration of the simple formula pattern, see the atomic formula and equation modules ( atom_backbone_module and equal_module) 
## an extension point for alternate spellings and internationalization of the disjunction tag name.  
Or-node.choice |= Or.Node.def
Or.Node.def =
    
    ## A disjunctive expression, where <Or>Atom</Or> is equivalent to Atom.
    ## See http://www.ruleml.org/1.0/glossary/#gloss-Or
    element Or { Or.attlist, Or.header, Or.main }
# The attribute list of the disjunction element is initialized empty , but may be over-ridden by optional modules.
Or.attlist &= empty

## an extension point for alternate spellings and internationalization of the disjunction tag name in queries.  
Or-Query-node.choice |= Or-Query.Node.def
Or-Query.Node.def = element Or { Or-Query.attlist, Or.header, Or.main }

## Within query, disjunctions may have an optional existential closure attribute.
Or-Query.attlist &= closure-att.choice?
# For the declaration of the closure attribute pattern, see the quantification closure module (closure_extension_module)

## The header section of the implication content model follows a common pattern for formulas.
Or.header &= CompoundFormula.header?

## The main section of the conjunction content model contains zero or more formulas.
Or.main |= formula_Or-edge.choice*

## an extension point for stripe skipping as well as alternate spellings and internationalization of the formula tag name in disjunctions.  
formula_Or-edge.choice |= formula_Or.edge.def
formula_Or.edge.def =
    
    ## The formula role of a conjunctive (<And>) or disjunctive (<Or>) expression, 
    ## quantifier (<Forall> or <Exists>), or performative (<Assert>, <Query> or <Retract>).
    ## See http://www.ruleml.org/1.0/glossary/#gloss-formula
    ## Within Or ...
    element formula { formula_Or.content }

## Formulas within disjunctions consist of a single formula
formula_Or.content |= OrFormula.choice

## formulas allowed to participate in disjunctions. 
OrFormula.choice |=
    SimpleFormula-node.choice
    | And-node.choice
    | Or-node.choice
    | Negation-node.choice
    | NegationAsFailure-node.choice
    | Implication-fo-node.choice
    | Forall-fo-node.choice
    | Exists-fo-node.choice
# For the declaration of the simple formula pattern, see the atomic formula and equation modules ( atom_backbone_module and equal_module) 
# For the declaration of the strong negation formula pattern, see the strong negation module ( neg_extension_module) 
# For the declaration of the weak negation formula pattern, see the weak negation module ( naf_extension_module) 
# For the declaration of the implication pattern, see the implication modules (implication_module and equivalence_module)
# For the declaration of the quantification patterns, see the quantification module (quantifier_module)
#
Node.choice |= andor.Node.defs
edge.choice |= andor.edge.defs
# Optional initialization modules allows this module to be independently validated
# include "init_extension_module.rnc"
