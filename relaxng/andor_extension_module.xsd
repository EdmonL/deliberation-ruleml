<?xml version="1.0" encoding="UTF-8"?>
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema" elementFormDefault="qualified" targetNamespace="http://www.ruleml.org/0.91/xsd" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:ruleml="http://www.ruleml.org/0.91/xsd">
  <xs:import namespace="http://www.w3.org/2001/XMLSchema-instance" schemaLocation="explicit_datatyping_extension_module.xsd"/>
  <!--
    This module declares the following RuleML elements and attributes:
               * <And>
               * <Or>
               * <formula>
    This module also declares the following RuleML choice pattern:
               * AndFormula.choice
               * OrFormula.choice
  -->
  <xs:group name="andor.Node.defs">
    <xs:choice>
      <xs:group ref="ruleml:And.Node.def"/>
      <xs:group ref="ruleml:Or.Node.def"/>
      <xs:group ref="ruleml:And-Query.Node.def"/>
      <xs:group ref="ruleml:Or-Query.Node.def"/>
    </xs:choice>
  </xs:group>
  <xs:group name="andor.edge.defs">
    <xs:choice>
      <xs:group ref="ruleml:formula_And.edge.def"/>
      <xs:group ref="ruleml:formula_Or.edge.def"/>
    </xs:choice>
  </xs:group>
  <xs:group name="And-node.choice">
    <xs:annotation>
      <xs:documentation>an extension point for alternate spellings and internationalization of the conjunction tag name.</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:group ref="ruleml:And.Node.def"/>
    </xs:sequence>
  </xs:group>
  <xs:group name="And.Node.def">
    <xs:sequence>
      <xs:element name="And">
        <xs:annotation>
          <xs:documentation>A conjunctive expression, where &lt;And&gt;Atom&lt;/And&gt; is equivalent to Atom.
See http://www.ruleml.org/0.91/glossary/#gloss-And
Within anything other than Query...</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:sequence>
            <xs:group ref="ruleml:And.header"/>
            <xs:group ref="ruleml:And.main"/>
          </xs:sequence>
        </xs:complexType>
      </xs:element>
    </xs:sequence>
  </xs:group>
  <!-- The attribute list of the conjunction element is initialized empty , but may be over-ridden by extension modules. -->
  <xs:group name="And-Query-node.choice">
    <xs:annotation>
      <xs:documentation>an extension point for alternate spellings and internationalization of the conjunction tag name in queries.  </xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:group ref="ruleml:And-Query.Node.def"/>
    </xs:sequence>
  </xs:group>
  <xs:group name="And-Query.Node.def">
    <xs:sequence>
      <xs:element name="And">
        <xs:annotation>
          <xs:documentation>A conjunctive expression, where &lt;And&gt;Atom&lt;/And&gt; is equivalent to Atom.
See http://www.ruleml.org/0.91/glossary/#gloss-And
Within Query...</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:sequence>
            <xs:group ref="ruleml:And.header"/>
            <xs:group ref="ruleml:And.main"/>
          </xs:sequence>
          <xs:attributeGroup ref="ruleml:And-Query.attlist"/>
        </xs:complexType>
      </xs:element>
    </xs:sequence>
  </xs:group>
  <xs:attributeGroup name="And-Query.attlist">
    <xs:annotation>
      <xs:documentation>Within query, conjunctions may have an optional existential closure attribute.</xs:documentation>
    </xs:annotation>
    <xs:attributeGroup ref="ruleml:closure-att.choice"/>
  </xs:attributeGroup>
  <!-- For the declaration of the closure attribute pattern, see the quantification closure module (closure_extension_module) -->
  <xs:group name="And.header">
    <xs:annotation>
      <xs:documentation>The header section of the implication content model follows a common pattern for formulas.</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:group minOccurs="0" ref="ruleml:CompoundFormula.header"/>
    </xs:sequence>
  </xs:group>
  <xs:group name="CompoundFormula.header">
    <xs:annotation>
      <xs:documentation>Compound formulas are crisp (not fuzzifiable) and therefore contain only the pattern for general formulas</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:group minOccurs="0" ref="ruleml:Formula.header"/>
    </xs:sequence>
  </xs:group>
  <!--
    The formula header may be serialization-dependent, 
    see the serialization modules (orderlax_module, orderstrict_module, ordermix_module).
  -->
  <xs:group name="And.main">
    <xs:annotation>
      <xs:documentation>The main section of the conjunction content model contains zero or more formulas.</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:group minOccurs="0" maxOccurs="unbounded" ref="ruleml:formula_And-edge.choice"/>
    </xs:sequence>
  </xs:group>
  <xs:group name="formula_And-edge.choice">
    <xs:annotation>
      <xs:documentation>an extension point for stripe skipping as well as alternate spellings and internationalization of the formula tag name in conjunctions.  </xs:documentation>
    </xs:annotation>
    <xs:choice>
      <xs:group ref="ruleml:formula_And.edge.def"/>
      <xs:group ref="ruleml:formula_And.content"/>
    </xs:choice>
  </xs:group>
  <xs:group name="formula_And.edge.def">
    <xs:sequence>
      <xs:element name="formula">
        <xs:annotation>
          <xs:documentation>The formula role of a conjunctive (&lt;And&gt;) or disjunctive (&lt;Or&gt;) expression, 
quantifier (&lt;Forall&gt; or &lt;Exists&gt;), or performative (&lt;Assert&gt;, &lt;Query&gt; or &lt;Retract&gt;).
See http://www.ruleml.org/0.91/glossary/#gloss-formula
Within And ...</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:group ref="ruleml:formula_And.content"/>
        </xs:complexType>
      </xs:element>
    </xs:sequence>
  </xs:group>
  <xs:group name="formula_And.content">
    <xs:annotation>
      <xs:documentation>Formulas within disjunctions consist of a single formula</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:group ref="ruleml:AndFormula.choice"/>
    </xs:sequence>
  </xs:group>
  <xs:group name="AndFormula.choice">
    <xs:annotation>
      <xs:documentation>formulas allowed to participate in conjunctions. </xs:documentation>
    </xs:annotation>
    <xs:choice>
      <xs:group ref="ruleml:SimpleFormula-node.choice"/>
      <xs:group ref="ruleml:And-node.choice"/>
      <xs:group ref="ruleml:Or-node.choice"/>
    </xs:choice>
  </xs:group>
  <!--
    For the declaration of the simple formula pattern, see the atomic formula and equation modules ( atom_backbone_module and equal_module) 
    For the declaration of the strong negation formula pattern, see the strong negation module ( neg_extension_module) 
    For the declaration of the weak negation formula pattern, see the weak negation module ( naf_extension_module) 
    For the declaration of the implication pattern, see the implication modules (implication_module and equivalence_module)
    For the declaration of the quantification patterns, see the quantification module (quantifier_module)
  -->
  <xs:group name="Or-node.choice">
    <xs:annotation>
      <xs:documentation>a convenience pattern that unifies atomic formulas and equations
because equations are allowed wherever atomic formulas are allowed.</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:group ref="ruleml:Or.Node.def"/>
    </xs:sequence>
  </xs:group>
  <xs:group name="Or.Node.def">
    <xs:sequence>
      <xs:element name="Or">
        <xs:annotation>
          <xs:documentation>A disjunctive expression, where &lt;Or&gt;Atom&lt;/Or&gt; is equivalent to Atom.
See http://www.ruleml.org/0.91/glossary/#gloss-Or</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:sequence>
            <xs:group ref="ruleml:Or.header"/>
            <xs:group ref="ruleml:Or.main"/>
          </xs:sequence>
        </xs:complexType>
      </xs:element>
    </xs:sequence>
  </xs:group>
  <!-- The attribute list of the disjunction element is initialized empty , but may be over-ridden by optional modules. -->
  <xs:group name="Or-Query-node.choice">
    <xs:annotation>
      <xs:documentation>an extension point for alternate spellings and internationalization of the disjunction tag name in queries.  </xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:group ref="ruleml:Or-Query.Node.def"/>
    </xs:sequence>
  </xs:group>
  <xs:group name="Or-Query.Node.def">
    <xs:sequence>
      <xs:element name="Or">
        <xs:complexType>
          <xs:sequence>
            <xs:group ref="ruleml:Or.header"/>
            <xs:group ref="ruleml:Or.main"/>
          </xs:sequence>
          <xs:attributeGroup ref="ruleml:Or-Query.attlist"/>
        </xs:complexType>
      </xs:element>
    </xs:sequence>
  </xs:group>
  <xs:attributeGroup name="Or-Query.attlist">
    <xs:annotation>
      <xs:documentation>Within query, disjunctions may have an optional existential closure attribute.</xs:documentation>
    </xs:annotation>
    <xs:attributeGroup ref="ruleml:closure-att.choice"/>
  </xs:attributeGroup>
  <!-- For the declaration of the closure attribute pattern, see the quantification closure module (closure_extension_module) -->
  <xs:group name="Or.header">
    <xs:annotation>
      <xs:documentation>The header section of the implication content model follows a common pattern for formulas.</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:group minOccurs="0" ref="ruleml:CompoundFormula.header"/>
    </xs:sequence>
  </xs:group>
  <xs:group name="Or.main">
    <xs:annotation>
      <xs:documentation>The main section of the conjunction content model contains zero or more formulas.</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:group minOccurs="0" maxOccurs="unbounded" ref="ruleml:formula_Or-edge.choice"/>
    </xs:sequence>
  </xs:group>
  <xs:group name="formula_Or-edge.choice">
    <xs:annotation>
      <xs:documentation>an extension point for stripe skipping as well as alternate spellings and internationalization of the formula tag name in disjunctions.  </xs:documentation>
    </xs:annotation>
    <xs:choice>
      <xs:group ref="ruleml:formula_Or.edge.def"/>
      <xs:group ref="ruleml:formula_Or.content"/>
    </xs:choice>
  </xs:group>
  <xs:group name="formula_Or.edge.def">
    <xs:sequence>
      <xs:element name="formula">
        <xs:annotation>
          <xs:documentation>The formula role of a conjunctive (&lt;And&gt;) or disjunctive (&lt;Or&gt;) expression, 
quantifier (&lt;Forall&gt; or &lt;Exists&gt;), or performative (&lt;Assert&gt;, &lt;Query&gt; or &lt;Retract&gt;).
See http://www.ruleml.org/0.91/glossary/#gloss-formula
Within Or ...</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:group ref="ruleml:formula_Or.content"/>
        </xs:complexType>
      </xs:element>
    </xs:sequence>
  </xs:group>
  <xs:group name="formula_Or.content">
    <xs:annotation>
      <xs:documentation>Formulas within disjunctions consist of a single formula</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:group ref="ruleml:OrFormula.choice"/>
    </xs:sequence>
  </xs:group>
  <xs:group name="OrFormula.choice">
    <xs:annotation>
      <xs:documentation>formulas allowed to participate in disjunctions. </xs:documentation>
    </xs:annotation>
    <xs:choice>
      <xs:group ref="ruleml:SimpleFormula-node.choice"/>
      <xs:group ref="ruleml:And-node.choice"/>
      <xs:group ref="ruleml:Or-node.choice"/>
    </xs:choice>
  </xs:group>
  <!--
    For the declaration of the simple formula pattern, see the atomic formula and equation modules ( atom_backbone_module and equal_module) 
    For the declaration of the strong negation formula pattern, see the strong negation module ( neg_extension_module) 
    For the declaration of the weak negation formula pattern, see the weak negation module ( naf_extension_module) 
    For the declaration of the implication pattern, see the implication modules (implication_module and equivalence_module)
    For the declaration of the quantification patterns, see the quantification module (quantifier_module)
    
  -->
</xs:schema>
<!--
  Optional initialization modules allows this module to be independently validated
  include "init_extension_module.rnc"
-->
