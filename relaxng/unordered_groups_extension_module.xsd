<?xml version="1.0" encoding="UTF-8"?>
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema" elementFormDefault="qualified" targetNamespace="http://www.ruleml.org/0.91/xsd" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:ruleml="http://www.ruleml.org/0.91/xsd">
  <xs:import namespace="http://www.w3.org/2001/XMLSchema-instance" schemaLocation="explicit_datatyping_extension_module.xsd"/>
  <xs:group name="Atom.main">
    <xs:annotation>
      <xs:documentation>Pre-fix operator notation for atomic formulas is optional in a relaxed-form serialization.
This pattern cannot be translated accurately into XSD.</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:choice minOccurs="0" maxOccurs="unbounded">
        <xs:group ref="ruleml:operatorForAtoms-edge.choice"/>
        <xs:group ref="ruleml:argumentsForAtoms.sequence"/>
      </xs:choice>
    </xs:sequence>
  </xs:group>
  <xs:group name="argumentsForAtoms.sequence">
    <xs:sequence>
      <xs:choice minOccurs="0" maxOccurs="unbounded">
        <xs:choice>
          <xs:group ref="ruleml:positionalArgument-edge.choice"/>
          <xs:group ref="ruleml:positionalArgument-edge.choice"/>
        </xs:choice>
        <xs:group ref="ruleml:slotsForAtoms.sequence"/>
      </xs:choice>
    </xs:sequence>
  </xs:group>
  <xs:group name="positionalArgumentsForAtoms.sequence">
    <xs:sequence>
      <xs:group ref="ruleml:termsForAtoms.sequence"/>
    </xs:sequence>
  </xs:group>
  <xs:group name="termsForAtoms.sequence">
    <xs:sequence>
      <xs:group minOccurs="0" ref="ruleml:termsPlus.sequence"/>
    </xs:sequence>
  </xs:group>
  <xs:group name="slotsForAtoms.sequence">
    <xs:sequence>
      <xs:group ref="ruleml:slotTermsForAtoms.sequence"/>
    </xs:sequence>
  </xs:group>
  <xs:group name="argumentsForExpressions.sequence">
    <xs:sequence>
      <xs:choice minOccurs="0" maxOccurs="unbounded">
        <xs:choice>
          <xs:group ref="ruleml:positionalArgument-edge.choice"/>
          <xs:group ref="ruleml:positionalArgument-edge.choice"/>
        </xs:choice>
        <xs:group ref="ruleml:slotsForExpressions.sequence"/>
      </xs:choice>
    </xs:sequence>
  </xs:group>
  <xs:group name="positionalArgumentsForExpressions.sequence">
    <xs:sequence>
      <xs:group minOccurs="0" ref="ruleml:termsForExpressions.sequence"/>
    </xs:sequence>
  </xs:group>
  <xs:group name="termsForExpressions.sequence">
    <xs:sequence>
      <xs:group minOccurs="0" ref="ruleml:termsPlus.sequence"/>
    </xs:sequence>
  </xs:group>
  <xs:group name="slotsForExpressions.sequence">
    <xs:sequence>
      <xs:group minOccurs="0" ref="ruleml:slotTermsForExpressions.sequence"/>
    </xs:sequence>
  </xs:group>
  <!---->
  <xs:group name="Entails.main">
    <xs:annotation>
      <xs:documentation>In the lax-order serialization, the body and head of a proof-theoretic entailment can occur in either order if striped.
This pattern can be translated accurately into XSD.</xs:documentation>
    </xs:annotation>
    <xs:choice>
      <xs:choice minOccurs="0" maxOccurs="unbounded">
        <xs:group ref="ruleml:body_Entails.name.choice"/>
        <xs:group ref="ruleml:head_Entails.name.choice"/>
      </xs:choice>
      <xs:sequence>
        <xs:group ref="ruleml:head_Entails-ss.content"/>
        <xs:group ref="ruleml:body_Entails.name.choice"/>
      </xs:sequence>
      <xs:sequence>
        <xs:group ref="ruleml:head_Entails.name.choice"/>
        <xs:group ref="ruleml:body_Entails-ss.content"/>
      </xs:sequence>
      <xs:sequence>
        <xs:group ref="ruleml:body_Entails-ss.content"/>
        <xs:group ref="ruleml:head_Entails-ss.content"/>
      </xs:sequence>
      <xs:sequence>
        <xs:group ref="ruleml:body_Entails-ss.content"/>
        <xs:group ref="ruleml:head_Entails.name.choice"/>
      </xs:sequence>
      <xs:sequence>
        <xs:group ref="ruleml:body_Entails.name.choice"/>
        <xs:group ref="ruleml:head_Entails-ss.content"/>
      </xs:sequence>
    </xs:choice>
  </xs:group>
  <xs:group name="FuzzyFormula-header.choice">
    <xs:annotation>
      <xs:documentation>In the lax-order serialization, the object identifier occupies any position in the header of fuzzifiable formulas.
This pattern can be translated accurately into XSD using xs:any, but is not correctly translated by the Trang software.
The header for fuzzifiable formulas interleaves the patterns for general formulas and fuzzifiable objects.</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:choice minOccurs="0" maxOccurs="unbounded">
        <xs:group ref="ruleml:Formula.header"/>
        <xs:group ref="ruleml:Fuzzy.header"/>
      </xs:choice>
    </xs:sequence>
  </xs:group>
  <!--
    
    
    STRIPE-SKIPPING AND POSITIONAL-DNDEPENDENCE
    RELAX NG ENHANCEMENT
  -->
  <!---->
</xs:schema>
<!--
  
  Optional initialization module allows this module to be independently validated
  include "init_extension_module.rnc"
-->
