<?xml version="1.0" encoding="UTF-8"?>
<grammar xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:a="http://relaxng.org/ns/compatibility/annotations/1.0" xmlns="http://relaxng.org/ns/structure/1.0" datatypeLibrary="http://www.w3.org/2001/XMLSchema-datatypes">
  <dc:title>RuleML Basic Terms</dc:title>
  <dc:version>0.91.01</dc:version>
  <dc:creator>Tara Athan (taraathan AT gmail.com</dc:creator>
  <dc:subject>RuleML, term, individual</dc:subject>
  <dc:description>The auxiliary module for basic terms.</dc:description>
  <dc:date>2011-04-18</dc:date>
  <dc:language>en</dc:language>
  <dc:rights>TBD</dc:rights>
  <dc:relation>http://wiki.ruleml.org/index.php/Relax_NG</dc:relation>
  <start combine="choice">
    <choice>
      <ref name="Ind.Node.def"/>
      <ref name="arg.edge.def"/>
    </choice>
  </start>
  <!--
    This module declares the following RuleML elements, attributes and patterns:
               * <arg>
               * <Ind>
               * @index
  -->
  <define name="positionalArgument-edge.choice" combine="choice">
    <a:documentation>an extension point for stripe skipping as well as alternate spellings and internationalization of the positional argument tag name. </a:documentation>
    <ref name="arg.edge.def"/>
  </define>
  <define name="arg.edge.def">
    <element name="arg">
      <a:documentation>A role used for the positional arguments of a logical atom (&lt;Atom&gt;), i.e. any of the following: &lt;Ind&gt;, &lt;Data&gt;, &lt;Var&gt;, &lt;Skolem&gt; or &lt;Reify&gt; (also &lt;Expr&gt; and &lt;Plex&gt; in non-Datalog sublanguages).
See http://www.ruleml.org/0.91/glossary/#gloss-arg</a:documentation>
      <ref name="arg.attlist.choice">
        <a:documentation>The attribute @index is required for the positional argument role (property).</a:documentation>
      </ref>
      <ref name="arg.content"/>
    </element>
  </define>
  <define name="arg.attlist.choice">
    <interleave>
      <ref name="arg.attlist.req.def"/>
      <ref name="arg.attlist.opt.interleave"/>
    </interleave>
  </define>
  <define name="arg.attlist.req.def">
    <ref name="index.attrib.def"/>
  </define>
  <define name="arg.attlist.opt.interleave" combine="interleave">
    <empty/>
  </define>
  <define name="index.attrib.def">
    <a:documentation/>
    <attribute name="index">
      <a:documentation>A required attribute for specifying the position of a positional argument (&lt;arg&gt;) within a logical atom (&lt;Atom&gt;).
See http://www.ruleml.org/0.91/glossary/#gloss-index</a:documentation>
      <ref name="index.value"/>
    </attribute>
  </define>
  <define name="index.value" combine="choice">
    <data type="positiveInteger"/>
  </define>
  <define name="arg.content" combine="choice">
    <a:documentation>The content model of positional arguments for atomic formulas consists of any single term.</a:documentation>
    <ref name="AnyTerm.choice"/>
  </define>
  <define name="AnyTerm.choice" combine="choice">
    <a:documentation>Terms may be simple or compound.
Simple terms are either constant or quantifiable (variable).</a:documentation>
    <ref name="SimpleConstantTerm.choice"/>
  </define>
  <define name="AnyTerm.choice" combine="choice">
    <ref name="SimpleQuantifiableTerm.choice"/>
  </define>
  <!-- For the declaration of the quantifiable term pattern, see the quantification module (quantifier_module) -->
  <define name="AnyTerm.choice" combine="choice">
    <a:documentation>Compound terms may be partially constant and partially quantifiable.</a:documentation>
    <ref name="CompoundTerm.choice"/>
  </define>
  <define name="SimpleConstantTerm.choice" combine="choice">
    <a:documentation>Skolem constants are simple constant terms, but are not used in keys. </a:documentation>
    <ref name="Skolem-node.choice"/>
  </define>
  <!-- For the declaration of skolem constants, see the skolem module (skolem_module). -->
  <define name="SimpleConstantTerm.choice" combine="choice">
    <a:documentation>Reified RuleML tags are simple constant terms, but are not used in keys.</a:documentation>
    <ref name="Reify-node.choice"/>
  </define>
  <!-- For the declaration of reification terms, see the reification module (reify_module). -->
  <define name="SimpleConstantTerm.choice" combine="choice">
    <a:documentation>All terms used in keys must be constants.</a:documentation>
    <ref name="SimpleKeyTerm.choice"/>
  </define>
  <define name="SimpleKeyTerm.choice" combine="choice">
    <a:documentation>Individuals and literals (data) are simple, constant terms, and may be used in slot keys.</a:documentation>
    <choice>
      <ref name="Individual-node.choice"/>
      <ref name="DataTerm.choice"/>
    </choice>
  </define>
  <define name="CompoundTerm.choice" combine="choice">
    <a:documentation>Compound terms are built up from other terms.
Compound terms include expressions.</a:documentation>
    <ref name="Expression-node.choice"/>
  </define>
  <!-- For the declaration of expressions terms, see the expression module (expr_module). -->
  <define name="CompoundTerm.choice" combine="choice">
    <a:documentation>Compound terms include generalized lists, a special expression that returns 
the object that is the list of the arguments.</a:documentation>
    <ref name="Plex_Any-node.choice"/>
  </define>
  <!-- For the declaration of generalized list terms, see the generalized list module (plex_module). -->
  <define name="DataTerm.choice" combine="choice">
    <a:documentation>Data terms are literals, and may have simple or complex datatypes.</a:documentation>
    <ref name="Data-node.choice"/>
  </define>
  <!-- For the declaration of data terms, see the data modules (data_module and complexdata_module). -->
  <define name="Individual-node.choice" combine="choice">
    <a:documentation>an extension point for alternate spellings and internationalization of the individual tag name. </a:documentation>
    <ref name="Ind.Node.def"/>
  </define>
  <define name="Ind.Node.def">
    <element name="Ind">
      <a:documentation>An individual constant, as in Predicate logic, which can also be considered to be a fixed argument like RDF resources.
See http://www.ruleml.org/0.91/glossary/#gloss-Ind</a:documentation>
      <ref name="Ind.attlist"/>
      <ref name="Ind.content"/>
    </element>
  </define>
  <define name="Ind.attlist" combine="interleave">
    <a:documentation>Individuals optionally accept the attribute patterns of resources, and objects with user-defined types.</a:documentation>
    <optional>
      <ref name="Resource.attlist"/>
    </optional>
  </define>
  <define name="Ind.attlist" combine="interleave">
    <optional>
      <ref name="Type.attlist"/>
    </optional>
  </define>
  <!--
    For the declaration of the attribute list for resources, see the uri modules (uri_module).
    For the declaration of the attribute list for objects with user-defined types, see the type module (type_module). 
  -->
  <define name="Ind.content" combine="choice">
    <a:documentation>The content model for individuals is text.</a:documentation>
    <text/>
  </define>
  <define name="Node.choice" combine="choice">
    <ref name="Ind.Node.def"/>
  </define>
  <define name="edge.choice" combine="choice">
    <ref name="arg.edge.def"/>
  </define>
</grammar>
<!--
  
  Optional initialization module allows this module to be independently validated
  include "init_extension_module.rnc"
-->
