<?xml version="1.0" encoding="UTF-8"?>
<grammar xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:a="http://relaxng.org/ns/compatibility/annotations/1.0" xmlns="http://relaxng.org/ns/structure/1.0">
  <dc:title>RuleML Rulebase</dc:title>
  <dc:version>0.91.01</dc:version>
  <dc:creator>Tara Athan (taraathan AT gmail.com</dc:creator>
  <dc:subject>RuleML, rulebase</dc:subject>
  <dc:description>The auxiliary module for the rulebase component.</dc:description>
  <dc:date>2011-04-18</dc:date>
  <dc:language>en</dc:language>
  <dc:rights>TBD</dc:rights>
  <dc:relation>http://wiki.ruleml.org/index.php/Relax_NG</dc:relation>
  <start combine="choice">
    <ref name="Rulebase.Node.def"/>
  </start>
  <!--
    This module declares or extends the following RuleML elements and attributes:
               * <Rulebase>
               * <formula>
  -->
  <define name="Rulebase-node.choice" combine="choice">
    <a:documentation>an extension point for alternate spellings and internationalization of the rulebase tag name.  </a:documentation>
    <ref name="Rulebase.Node.def"/>
  </define>
  <define name="Rulebase.Node.def">
    <element name="Rulebase">
      <a:documentation>A collection of rules that can be ordered or unordered, without or with duplicates. 
See http://www.ruleml.org/0.91/glossary/#gloss-Rulebase</a:documentation>
      <ref name="Rulebase.attlist"/>
      <ref name="Rulebase.header"/>
      <ref name="Rulebase.main"/>
    </element>
  </define>
  <define name="Rulebase.attlist" combine="interleave">
    <a:documentation>Rulebases may have an optional scope quantification closure attribute.</a:documentation>
    <optional>
      <ref name="mapClosure-att.choice"/>
    </optional>
  </define>
  <!--
    Rulebase.attlist = mapDirection-att.option & mapMaterial-att.option & mapClosure-att.choice?
    For the declaration of the scope closure attribute pattern, see the quantification closure module (closure_extension_module)
  -->
  <define name="Rulebase.header" combine="interleave">
    <a:documentation>Rulebases accept the header pattern of general formulas.</a:documentation>
    <optional>
      <ref name="Object.header"/>
    </optional>
  </define>
  <!--
    The object header may be positionally-dependent, 
    see the position-(in)dependence serialization modules (orderstrict_module, orderlax_module).
  -->
  <define name="Rulebase.main" combine="choice">
    <a:documentation>Rulebases contain zero or more formulas.</a:documentation>
    <zeroOrMore>
      <ref name="formula_Rulebase-edge.choice"/>
    </zeroOrMore>
  </define>
  <define name="formula_Rulebase-edge.choice" combine="choice">
    <a:documentation>an extension point for stripe skipping as well as alternate spellings and internationalization of the formula tag name in rulebases.  </a:documentation>
    <ref name="formula_Rulebase.edge.def"/>
  </define>
  <define name="formula_Rulebase.edge.def">
    <element name="formula">
      <a:documentation>The formula role of a conjunctive (&lt;And&gt;) or disjunctive (&lt;Or&gt;) expression, 
quantifier (&lt;Forall&gt; or &lt;Exists&gt;), or performative (&lt;Assert&gt;, &lt;Query&gt; or &lt;Retract&gt;).
See http://www.ruleml.org/0.91/glossary/#gloss-formula
Within Rulebase ...</a:documentation>
      <ref name="formula_Rulebase.content"/>
    </element>
  </define>
  <define name="formula_Rulebase.content" combine="choice">
    <ref name="RulebaseFormula.choice"/>
  </define>
  <define name="RulebaseFormula.choice" combine="choice">
    <a:documentation>formulas allowed to belong to a Rulebase: 
Atomic formulas are allowed in rulebases.</a:documentation>
    <choice>
      <ref name="SimpleFormula-node.choice"/>
      <ref name="And-fo-node.choice"/>
      <ref name="Or-fo-node.choice"/>
      <ref name="Negation-node.choice"/>
      <ref name="NegationAsFailure-node.notallowed"/>
      <ref name="Implication-node.choice"/>
      <ref name="Forall-node.choice"/>
      <ref name="Exists-fo-node.choice"/>
    </choice>
  </define>
  <!--
    For the declaration of the simple formula pattern, see the atomic formula and equation modules ( atom_backbone_module and equal_module) 
    For the declaration of conjunctive and disjunctive formula patterns, see the conjunction and disjunction module (andor_module)
    For the declaration of the strong negation formula pattern, see the strong negation module ( neg_extension_module) 
    For the declaration of the weak negation formula pattern, see the weak negation module ( naf_extension_module) 
    For the declaration of the implication pattern, see the implication modules (implication_module and equivalence_module)
    For the declaration of the quantification patterns, see the quantification module (quantifier_module)
  -->
  <define name="Node.choice" combine="choice">
    <ref name="Rulebase.Node.def"/>
  </define>
  <define name="edge.choice" combine="choice">
    <ref name="formula_Rulebase.edge.def"/>
  </define>
</grammar>
<!--
  
  Optional initialization module allows this module to be independently validated
  include "init_extension_module.rnc"
-->
