default namespace = "http://www.ruleml.org/1.0/xsd"

start =
  RuleML
  | Assert
  | Retract
  | _1
  | Atom
  | Rel
  | _2
  | _3
  | _4
  | _5
  | Data
  | Rulebase
  | Entails
  | Skolem
  | Reify
  | Ind
  | formula
  | formula_2
  | op
  | formula_3
  | formula_4
  | formula_5
  | then
  | if
  | degree
  | oid
  | slot
  | arg
RuleML =
  element RuleML {
    oid?,
    (act | (Assert | Retract | _1)*)+
  }
Assert =
  element Assert {
    (attribute mapMaterial { "yes" | "no" }?
     & attribute mapDirection {
         "bidirectional" | "forward" | "backward"
       }?
     & attribute mapClosure { "universal" | "existential" }?),
    oid?,
    (formula | Atom | Entails | Rulebase)*
  }
Retract =
  element Retract {
    (attribute mapMaterial { "yes" | "no" }?
     & attribute mapDirection {
         "bidirectional" | "forward" | "backward"
       }?
     & attribute mapClosure { "universal" | "existential" }?),
    oid?,
    (formula | Atom | Entails | Rulebase)*
  }
_1 = element * { notAllowed }
Atom =
  element Atom {
    attribute closure { "universal" | "existential" }?,
    (oid? & degree?),
    ((op | Rel)
     & ((Skolem | Reify | Ind | Data | Data_2 | arg),
        (Skolem | Reify | Ind | Data | Data_2 | arg))?
     & slot*)
  }
Rel =
  element Rel {
    attribute iri { xsd:anyURI }?,
    text
  }
_2 = element * { notAllowed }
_3 = element * { notAllowed }
_4 = element * { notAllowed }
_5 = element * { notAllowed }
Data =
  element Data {
    xsd:duration
    | xsd:dateTime
    | xsd:time
    | xsd:date
    | xsd:gYearMonth
    | xsd:gYear
    | xsd:gMonthDay
    | xsd:gDay
    | xsd:gMonth
    | xsd:boolean
    | xsd:base64Binary
    | xsd:hexBinary
    | xsd:float
    | xsd:decimal
    | xsd:double
    | xsd:anyURI
    | xsd:QName
    | xsd:NOTATION
    | xsd:string
  }
Rulebase =
  element Rulebase {
    (attribute mapMaterial { "yes" | "no" }?
     & attribute mapDirection {
         "bidirectional" | "forward" | "backward"
       }?
     & attribute mapClosure { "universal" | "existential" }?),
    oid?,
    (Atom | formula_5)*
  }
Entails =
  element Entails {
    oid?,
    ((if & then)
     | (Rulebase, if)
     | (then, Rulebase)
     | (Rulebase, Rulebase)
     | (Rulebase, then)
     | (if, Rulebase))
  }
Skolem =
  element Skolem {
    attribute type { xsd:string }?,
    text
  }
Reify =
  element Reify {
    (RuleML
     | Assert
     | Retract
     | _1
     | Atom
     | Rel
     | _2
     | _3
     | _4
     | _5
     | Data
     | Rulebase
     | Entails
     | Skolem
     | Reify
     | Ind
     | formula
     | formula_2
     | op
     | formula_3
     | formula_4
     | formula_5
     | then
     | if
     | degree
     | oid
     | slot
     | arg)?
  }
Ind =
  element Ind {
    (attribute iri { xsd:anyURI }?
     & attribute type { xsd:string }?),
    text
  }
formula = element formula { Atom | Entails | Rulebase }
formula_2 = element formula { Atom | _4 | _5 | Entails | Rulebase }
op = element op { Rel }
formula_3 = element formula { Atom | _2 | _3 }
formula_4 = element formula { Atom | _2 | _3 }
formula_5 = element formula { Atom }
then = element then { Rulebase }
if = element if { Rulebase }
degree = element degree { Data_2 | Data }
oid = element oid { Skolem | Reify | Ind | Data | Data_2 }
slot =
  element slot {
    (attribute card { xsd:nonNegativeInteger }?
     & attribute weight {
         xsd:decimal { minInclusive = "0.0" maxInclusive = "1.0" }
       }?),
    (Ind | Data | Data_2),
    (Skolem | Reify | Ind | Data | Data_2)
  }
arg =
  element arg {
    attribute index { xsd:positiveInteger },
    (Skolem | Reify | Ind | Data | Data_2)
  }
act =
  element act {
    attribute index { xsd:positiveInteger },
    (Assert | Retract | _1)*
  }
Data_2 = element Data { text & _6* }
_6 =
  element * {
    attribute * { text }*,
    (text & _6*)
  }
