default namespace = "http://www.ruleml.org/1.0/xsd"

start =
  _1
  | Query
  | Implies
  | Assert
  | Naf
  | arg
  | Retract
  | Data
  | Atom
  | if
  | repo
  | oid
  | Neg
  | Rulebase
  | _2
  | Expr
  | Reify
  | Equivalent
  | resl
  | op
  | Rel
  | Ind
  | declare
  | Plex
  | Fun
  | degree
  | Forall
  | _3
  | Exists
  | Or
  | _4
  | Skolem
  | _5
  | RuleML
  | act
  | Var
  | And
  | Entails
_1 = element * { notAllowed }
Query =
  element Query {
    attribute closure {
      xsd:NMTOKEN "universal" | xsd:NMTOKEN "existential"
    }?,
    oid?,
    (formula | Rulebase | And_2 | Or_2 | Entails | Exists | Naf)*
  }
Implies =
  element Implies {
    attribute material { xsd:NMTOKEN "yes" | xsd:NMTOKEN "no" }?,
    attribute direction {
      xsd:NMTOKEN "backward"
      | xsd:NMTOKEN "forward"
      | xsd:NMTOKEN "bidirectional"
    }?,
    attribute closure {
      xsd:NMTOKEN "universal" | xsd:NMTOKEN "existential"
    }?,
    oid?,
    ((_4, if) | (if, _4))
  }
Assert =
  element Assert {
    attribute mapMaterial { xsd:NMTOKEN "yes" | xsd:NMTOKEN "no" }?,
    attribute mapClosure {
      xsd:NMTOKEN "universal" | xsd:NMTOKEN "existential"
    }?,
    attribute mapDirection {
      xsd:NMTOKEN "backward"
      | xsd:NMTOKEN "forward"
      | xsd:NMTOKEN "bidirectional"
    }?,
    oid?,
    (formula_2 | Rulebase | Implies | Equivalent | Entails | Forall)*
  }
Naf = element Naf { oid?, _5 }
arg =
  element arg {
    attribute index { xsd:positiveInteger },
    (Var | Skolem | Reify)
  }
Retract =
  element Retract {
    attribute mapMaterial { xsd:NMTOKEN "yes" | xsd:NMTOKEN "no" }?,
    attribute mapClosure {
      xsd:NMTOKEN "universal" | xsd:NMTOKEN "existential"
    }?,
    attribute mapDirection {
      xsd:NMTOKEN "backward"
      | xsd:NMTOKEN "forward"
      | xsd:NMTOKEN "bidirectional"
    }?,
    oid?,
    (formula_2 | Rulebase | Implies | Equivalent | Entails | Forall)*
  }
Data =
  element Data {
    text
    & (attribute * { text }
       | _6)*
  }
Atom =
  element Atom {
    attribute closure {
      xsd:NMTOKEN "universal" | xsd:NMTOKEN "existential"
    }?,
    oid?,
    degree?,
    (op | Rel),
    _2*,
    ((((arg | Var | Skolem | Reify)+, repo?)
      | repo),
     _2*)?,
    resl?
  }
if = element if { And | Or | Naf }
repo = element repo { Var | Plex_2 }
oid = element oid { Var | Skolem | Reify }
Neg = element Neg { oid?, _3 }
Rulebase =
  element Rulebase {
    attribute mapMaterial { xsd:NMTOKEN "yes" | xsd:NMTOKEN "no" }?,
    attribute mapDirection {
      xsd:NMTOKEN "backward"
      | xsd:NMTOKEN "forward"
      | xsd:NMTOKEN "bidirectional"
    }?,
    attribute mapClosure {
      xsd:NMTOKEN "universal" | xsd:NMTOKEN "existential"
    }?,
    oid?,
    (formula_3 | Implies | Equivalent | Forall)*
  }
_2 = element * { notAllowed }
Expr =
  element Expr {
    attribute per { xsd:NMTOKEN "copy" }?,
    attribute type { xsd:string }?,
    oid?,
    (op_2 | Fun),
    _2*,
    ((((arg | Var | Skolem | Reify)+, repo?)
      | repo),
     _2*)?,
    resl?
  }
Reify =
  element Reify {
    (_1
     | Query
     | Implies
     | Assert
     | Naf
     | arg
     | Retract
     | Data
     | Atom
     | if
     | repo
     | oid
     | Neg
     | Rulebase
     | _2
     | Expr
     | Reify
     | Equivalent
     | resl
     | op
     | Rel
     | Ind
     | declare
     | Plex
     | Fun
     | degree
     | Forall
     | _3
     | Exists
     | Or
     | _4
     | Skolem
     | _5
     | RuleML
     | act
     | Var
     | And
     | Entails)?
  }
Equivalent =
  element Equivalent {
    attribute closure {
      xsd:NMTOKEN "universal" | xsd:NMTOKEN "existential"
    }?,
    oid?,
    _1,
    _1
  }
resl = element resl { Var | Plex_3 }
op = element op { Rel }
Rel =
  element Rel {
    text
    & attribute iri { xsd:anyURI }?
  }
Ind =
  element Ind {
    text
    & (attribute iri { xsd:anyURI }?,
       attribute type { xsd:string }?)
  }
declare = element declare { Var }
Plex =
  element Plex {
    oid?,
    _2*,
    (((arg | Var | Skolem | Reify)+, repo?, _2*, resl?)?
     | (repo, _2*, resl?)
     | resl)
  }
Fun =
  element Fun {
    text
    & (attribute per { xsd:NMTOKEN "copy" }?,
       attribute iri { xsd:anyURI }?)
  }
degree = element degree { Data }
Forall =
  element Forall {
    oid?, (declare | Var)+, (formula_4 | Implies | Equivalent | Forall)
  }
_3 = element * { notAllowed }
Exists =
  element Exists {
    oid?, (declare | Var)+, (formula_5 | And | Or | Exists)
  }
Or = element Or { oid?, (formula_6 | And | Or | Naf)* }
_4 = element * { notAllowed }
Skolem =
  element Skolem {
    text
    & attribute type { xsd:string }?
  }
_5 = element * { notAllowed }
RuleML = element RuleML { oid?, (act | Assert | Retract | Query)* }
act =
  element act {
    attribute index { xsd:positiveInteger },
    (Assert | Retract | Query)
  }
Var =
  element Var {
    text
    & attribute type { xsd:string }?
  }
And = element And { oid?, (formula_6 | And | Or | Naf)* }
Entails = element Entails { oid?, (if_2 | Rulebase), (then | Rulebase) }
formula =
  element formula { Rulebase | And_2 | Or_2 | Entails | Exists | Naf }
And_2 =
  element And {
    attribute closure {
      xsd:NMTOKEN "universal" | xsd:NMTOKEN "existential"
    }?,
    oid?,
    (formula_6 | And | Or | Naf)*
  }
Or_2 =
  element Or {
    attribute closure {
      xsd:NMTOKEN "universal" | xsd:NMTOKEN "existential"
    }?,
    oid?,
    (formula_6 | And | Or | Naf)*
  }
formula_2 =
  element formula { Rulebase | Implies | Equivalent | Entails | Forall }
_6 =
  element * {
    text
    & (attribute * { text }
       | _6)*
  }
Plex_2 = element Plex { (arg | Var | Skolem | Reify)*, repo? }
formula_3 = element formula { Implies | Equivalent | Forall }
op_2 = element op { Fun }
Plex_3 = element Plex { _2*, resl? }
formula_4 = element formula { Implies | Equivalent | Forall }
formula_5 = element formula { And | Or | Exists }
formula_6 = element formula { And | Or | Naf }
if_2 = element if { Rulebase }
then = element then { Rulebase }
